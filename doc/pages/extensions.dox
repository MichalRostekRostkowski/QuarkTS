/*! @page q_extensions Extensions
* @tableofcontents
* 
* @section q_stimers STimers
* There are several situations where the application does not need such hard 
* real-time precision for timing actions and we just need that a section of 
* code will execute when at least, some amount of time has elapsed. For these 
* purposes, STimers (Software-Timers) is the right extension to use.
*
* The STimers implementation does not access resources from the interrupt 
* context, does not consume any significant processing time unless a timer has 
* actually expired, does not add any processing overhead to the sys-tick 
* interrupt, and does not walk any other data structures. The timer service 
* just takes the value of the existing kernel clock source for reference 
* \f$ t_{sys}\f$ , allowing timer functionality to be added to an application 
* with minimal impact.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>stimer</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T15:06:53.012Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;D0ASMuxQqJpFRMXpmBB_\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;rcvfuREYuiKnwBi7l4OG\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>STimers operation</em>
* </center>
*
* As illustrated in the figure, the time expiration check is roll-over safe 
* by restricting it, to the only calculation that make sense for timestamps, 
* \f$ t_{sys} − X_{T_x} \f$, that yields a duration namely the amount of time 
* elapsed between the current instant \f$ t_{sys}\f$ and the later instant, 
* specifically, the tick taken at the arming instant with qSTimer_Set(), 
* \f$ X_{t_i}\f$
* Thanks to modular arithmetic, both of these are guaranteed to work fine across 
* the clock-source rollover (a 32bit unsigned-counter), at least, as long the 
* delays involved are shorter than @c 49.7 days.
*
* <b> Features </b>
*
* - Provides a non-blocking equivalent to delay function.
* - Each STimer encapsulates its own expiration (timeout) time.
* - Provides elapsed and remaining time APIs.
* - As mentioned before, STimers uses the same kernel clock source, this means 
* the time-elapsed calculation use the qClock_GetTick() API, therefore, the time
* resolution has the same value passed when the scheduler has been initialized
* with qOS_Setup()
*
* @subsection q_stimerusage Using a STimer
* A STimer is referenced by a handle, a variable of type qSTimer_t and 
* preferably, should be initialized by the @c QSTIMER_INITIALIZER constant
* before any usage.
*
* To use them, the code should follow a specific pattern that deals with the 
* states of this object. All related APIs are designed to be non-blocking, this
* means there are ideal for use in cooperative environments as the one provided 
* by the OS itself. To minimize the implementation, this object is intentionally
* created to behave like a binary object, this implies that it only handles two 
* states, @a Armed and @a Disarmed.
* An @a Armed timer means that it is already running with a specified preset 
* value and a @a Disarmed timer is the opposite, which means that it does not 
* have a preset value, so consequently, it is not running at all.
*
* The arming action can be performed with qSTimer_Set() or qSTimer_FreeRun() and
* disarming with qSTimer_Disarm().
* For qSTimer_FreeRun(), it checks the timer and performs the arming. If
* disarmed, it gets armed immediately with the specified time. If armed, the 
* time argument is ignored and the API only checks for expiration. When the time
* expires,the STimer gets armed immediately taking the specified time.
*
* All possible checking actions are also provided for this object, including 
* qSTimer_Elapsed(), qSTimer_Remaining() and qSTimer_Expired() , with the last 
* one being the most commonly used for timing applications. Finally, to get the 
* current status of the STimer (check if is @a Armed or @a Disarmed) the 
* qSTimer_Status() API should be used.
*
* @subsection q_stimerexample STimer example
* The example below shows a simple usage of this object. It is noteworthy that
* arming is performed once using the qEvent_t::FirstCall flag. This prevents the timer
* from being re-armed every time the task runs. After the timer expires, it
* should be disarmed explicitly
*
*  @code{.c}
*  void Example_Task( qEvent_t e ) {
*      static qSTimer_t timeout = QSTIMER_INITIALIZER;
*      if ( e->FirstCall ) {
*          /*Arming the stimer for  3.5 seg*/
*          qSTimer_Set( &timeout, 3.5f );
*      }
*      
*      /*non-blocking delay, true when timeout expires*/
*      if ( qSTimer_Expired( &timeout ) ) {
*          /* TODO: Code when STimer expires */
*          qSTimer_Disarm( &timeout );
*      }
*      else return; /*Yield*/
*  }
*  @endcode
*
* @section q_fsm Finite State Machines (FSM)
* The state machine is one of the fundamental programming patterns that are 
* most commonly used. This approach breaks down the design into a series of 
* finite steps called "states" that perform some narrowly defined actions. 
* Every state can change to another as a consequence of incoming stimuli also 
* called events or signals. This elemental mechanism allows designers to solve 
* complex engineering problems in a very straightforward way. Knowing the 
* importance of this approach in the development of embedded applications, 
* the OS adopts this design pattern as a kernel extension.
*
* In an effort to maximize efficiency and minimize complexity, the extension 
* implements the basic features of the Harel statecharts to represent
* hierarchical state machines. This features form a proper subset that 
* approaches in a very minimalist way, some of the specifications of the 
* UML statecharts, including:
*
* - Nested states with proper handling of group transitions and group reactions.
* - Guaranteed execution of entry/exit actions upon entering/exiting states.
* - Straightforward transitions and guards.
*
* In addition to this, the provided implementation also features a powerful 
* coding abstraction including transition tables and timeout signals, allowing 
* to build scalable solutions from simple flat state-machines to complex 
* statecharts.
* 
* @subsection qfsm_approach The provided approach
* In QuarkTS, a state-machine must be instantiated with an object of type qSM_t.
* States are represented as instances of the qSM_State_t object.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>fsmdesign</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T18:10:14.990Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;Pus0kYQw-gJYphxEF1EV\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;64UyDokTRLeBllNpieF3\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>FSM module design</em>
* </center>
*
* One important attribute of the qSM_State_t object is the callback function, 
* which is used to describe the behavior specific to the state. Also there is a 
* pointer to the parent state to define nesting of the state and its place in 
* the hierarchical topology. As shown in figure above, a state machine consist 
* of a least one state, the "top level" state. So concrete state machine are 
* built by adding an arbitrary number states and defining callback functions.
* The only purpose of the top state is to provide the root of the hierarchy, so 
* that the highest level can return to top as their parent state.
*
* @subsection q_fsmsetup Setting up a state machine
* Like any other OS object, a Finite State Machine (FSM) must be explicitly 
* initialized before it can be used. The qStateMachine_Setup() API initializes 
* the instance, sets the callback for the top state, sets the initial state and 
* the surrounding callback function.
*
* @subsection q_fsm_subscribe_states Subscribing states and defining callbacks
* State machines are constructed by composition, therefore, the topology of a 
* state machine is determined upon construction. In this FSM implementation, 
* there are not distinction between composite states(states containing substates) 
* and leaf states. All states are potentially composite. The API 
* qStateMachine_StateSubscribe() should be used to initialize the state and 
* define its position in the topology. 
*
* A state callback-functions takes a qSM_Handler_t object as input argument and
* returns a @ref qSM_Status_t value. An example is shown in the following code snippet:
*
*  @code{.c}
*  qSM_Status_t ExampleState_Callback( qSM_Handler_t h ) {
*      /* TODO: State code */
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode
*
* @subsection q_fsmhandler The state callback handler: performing transitions and retreiving data
* Because callback functions are methods derived from the state-machine object, 
* they have direct access to some attributes via the qSM_Handler_t argument. 
* The usage of this object it's required to make the FSM moves between states 
* and additionally get extra data. The provided attributes are:
*
* - qSM_Handler_t::NextState : Desired next state. The application writer should 
* change this field to another state to produce a state transition in the next 
* FSM's cycle. Changing this field will only take effect when the state is 
* executed under user custom-defined signals or in the absence of signals 
* #QSM_SIGNAL_NONE.
* - qSM_Handler_t::StartState : Desired nested initial state (substate). The 
* application writer should change this field to set the initial transition if
* the current state its a parent(or composite state). Changing this field 
* attribute only take effect when the state is executed under the 
* #QSM_SIGNAL_START signal. 
* - qSM_Handler_t::Signal (read-only) : Received signal. Can have any of the 
* following values:
*     - #QSM_SIGNAL_NONE if no signal available.
*     - #QSM_SIGNAL_ENTRY if the current state has just entered from another state.
*     - #QSM_SIGNAL_START to set nested initial transitions by using the 
*       qSM_Handler_t::StartState attribute.
*     - #QSM_SIGNAL_EXIT if the current state has just exit to another state.
*     - Any other user-defined signal will reside here, including the 
*     #QSM_SIGNAL_TIMEOUT signals.
* - qSM_Handler_t::SignalData (read-only) : Pointer to the data associated with
* the signal. For internal signals, including timeout signals, its value will 
* be @c NULL.
* - qSM_Handler_t::TransitionHistory : Use this option if the transition is to 
* a composite state. This attribute defines how the story should be handled. 
* If this field is not established, ::qSM_TRANSITION_NO_HISTORY is assumed. 
* The possible values for this attribute are:
*     - ::qSM_TRANSITION_NO_HISTORY : History is not preserved. Composite states 
*       will start according to their default transition.
*     - ::qSM_TRANSITION_SHALLOW_HISTORY : History will be kept to allow the 
*       return to only the top-most sub-state of the most recent state 
*       configuration, which is entered using the default entry rule.
*     - ::qSM_TRANSITION_DEEP_HISTORY : History will be kept to allow full state
*       configuration of the most recent visit to the containing region.
* - qSM_Handler_t::Status (read-only) :  The exit(or return) status of the last 
* state. Should be used in the Surrounding callback to perform the corresponding
* actions for every value. On states callback will take the value ::qSM_STATUS_NULL
* - qSM_Handler_t::machine (read-only) : A generic pointer to the container 
* state machine.
* - qSM_Handler_t::Data (read-only) : State-machine associated data. If the FSM
* is running as a task, the associated event data can be queried through this 
* field. (here, a cast to qEvent_t is mandatory).
* - qSM_Handler_t::StateData (read-only) : State associated data. Storage-pointer.
*
* Within the callback function of every state, only one level of dispatching 
* (based on the signal) is necessary. Typically this is archived using a 
* single-level switch statement. Callback functions communicate with the state 
* machine engine through the qSM_Handler_t and the return value of type 
* @ref qSM_Status_t.
*
* The semantic is simple, if a signal is processed, the callback functions 
* returns the status value ::qSM_STATUS_SIGNAL_HANDLED. otherwise it throws the
* signal for further processing by higher-level states. Also, this returning
* mechanism can be used to handle exceptions by using the surrounding callback.
*
* @a Entry/Exit actions and default transitions are also implemented inside the
* callback function in response of pre-defined signals. #QSM_SIGNAL_ENTRY, 
* #QSM_SIGNAL_EXIT and #QSM_SIGNAL_START. The state machine generates and 
* dispatches this signals to appropriates handlers upon  state transitions.
*
* The example below shows what a status callback should look like including the 
* use of the handler.
*
*  @code{.c}
*  qSM_Status_t ExampleState_Callback ( qSM_Handler_t h ) {
*      switch( h ) {
*          case QSM_SIGNAL_START:
*              break;
*          case QSM_SIGNAL_ENTRY:
*              break;
*          case QSM_SIGNAL_EXIT:
*              break;
*          case USER_DEFINED_SIGNAL :
*              h->NextState = &OtherState; /*transition*/
*              break;
*          default:
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode 
*
* As shown above, the return value represents the exit status of the state, and 
* it can be handled with an additional surrounding callback function \f$ S_u \f$ 
* established at the moment of the FSM setup. The values allowed to return are
* listed below.
*
* - ::qSM_STATUS_EXIT_SUCCESS
* - ::qSM_STATUS_EXIT_FAILURE
* - ::qSM_STATUS_SIGNAL_HANDLED
* - Any other integer value between @c -32762 and @c 32767
*
* To code initial transitions, application writer should catch the 
* #QSM_SIGNAL_START, perform the required actions and then designate the target 
* sub-state by assigning the @c StartState attribute of the qSM_Handler_t 
* argument. Regular transitions are coded in a very similar  way, except that 
* here, you catch the custom-defined signal and then assign the @c NextState
* attribute of the qSM_Handler_t argument. The developer is free to write and 
* control state transitions. Transitions are only allowed under the availability
* of user custom-defined signals. Regular transitions are not allowed at an 
* entry point (#QSM_SIGNAL_ENTRY), exit point (#QSM_SIGNAL_EXIT), or a start 
* point (#QSM_SIGNAL_START).
*
* @note User should not target the top state in a transition and use it as 
* transition source either. The only customizable aspect of the top state is 
* the initial transition.
*
* @subsection q_fsm_surrounding The surrounding callback
* It is a checkpoint before and after each state executes its activities 
* through its state callback. The behavior of this surrounding callback must be 
* defined by the programmer.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>surrounding</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T05:34:37.293Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;poDBqKg0qx6tawrUZqnR\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;4V9vBTZxQXj7jBstcZzX\&quot; name=\&quot;Página-1\&quot;&gt;7Zpdb6M4FIZ/TS7HMgaDuWzSdEejdlRttZqdq5ULboLGwZEx+dhfvzYxgWDSyc6kKbuTpFLx8fd5H7CPycifLDa/SbqcP4iU8RGC6Wbk344Q8iCO9D9j2VpLDHeGmcxSa2oMT9nfrK5prWWWsuKgoBKCq2x5aExEnrNEHdiolGJ9WOxF8MNel3TGHMNTQrlr/ZKlam6tXhg3GR9ZNpvbrgmyE17QurCdSTGnqVi3TP505E+kEGp3tdhMGDfOq/2yq3d3JHc/MMlydUqFh+jz/GG6Wtze/5X+8eUTI58W+INtZUV5aSdsB6u2tQekKPOUmUbgyB+v55liT0uamNy11lzb5mrBdcrTl4WS4hubCC5kVduPq4/Oeck4r+25yJkxiVzd0UXGDRsfGV8xlSV030rtb+2pcUqLeTUG04kdM5OKbY46w9u7WLPJxIIpudVFbIUwhICQXa2aTIz8nWHdCK15BZ71ybwlc00xtXjN9j00CugLK8K/EAQ5gjw6iuhmNP7s+2pw+sz4mCbfZpWIXfdrRZ5sq4XgZliHktyXSZZS3fdE5LpALZm9ST1s0y21CTTfPg4gjO7u7nq1bZOhS04mU1yVrPqy4/POoHmEESCoo7nvA0Qc2QMMfM9VPfABjN5IeN8R/mmEQq6My8pnfTkzl2Vt0320zP8LRDo5ryAyDc33DRAhKNwrPDxEgisi749IGBG9csD9xxsqLbhvJXFoGaGxdwWmtSFpWDn/riOGROvdsDPYxSg8iZ0PV3IuRU4IIYDwP0BO5JAzKWU1yy4U2hnKcXxL6Y6J8myW62Si22LaPjb+1OECv7EZiyxNK8kLjVeWz+7Zi5lv0Fh+ty4wJqGrv/AqHpvriky3MF6KLFeVQ/BY/+kt/gQCPMJ6tBOd9pq0/jPFpTKgKUmzSkVGC7VmhZmVFIoq+lzNtYKoDv68Vxg8Gg8dhmAukGfZHMMOUgQ6PGFvHzS1eUIQIPxGPBGHpzF7EZLd5NsrUYMmKozM1L7LVBhcnKm4b3WDkqlS5iNziqKXP98zjtkVuXI2ZM6IFwEUnABaDLzIBc1/q5Oc+gSzhdlnA86VpkHTRHyAg+PhXQ9YcQzCCz/BPPfc9lGyVSbK4srXoPnCelV0DiEHApV79uxGcnl6Y96qGEA4LYosOQzg+jzYewpc62SKJaVc7YMl1+vas3L7py1bJb6aBMB18nbTzrzd2tRu8Cx1XvB0tEJQUTlj6hXXBP2atrfG0BWrtknGqcpWh8Pok8/28Gjuj9ZGKghA90wSBwCTw4YKUcqE2brt90Dd5kLS11zsxftPp+Wde5yWK8j23vgJ7tyj70Fwdyo/78UFjsIeKqJGRvyDgMBuKGjwQJdlwj3rHgQTA3gWofdkLkI+6K5e56EuwhHwm2bCbuioeyEeviyE7hH6LwHhu8EVE4De5plGUARI0wzqYfjidLmH7L8EXSc84vB7UkjMDj0+HgGeB0jdAcCwAXIAPLpH9wAAB8lrOHm2cLL1bgqd6T0RDrrr5pE3Qz33DwpBhI7fLUdiS51sfsO2Y7H5JaA//Qc=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Surrounding callback invocation after and before the current state</em>
* </center>
*
* The surrounding callback \f$ S_u \f$ invocation occurs after and before the
* current state \f$ P \f$. When the surrounding callback is executed, indicates 
* its own checkpoint through the @c Status attribute of the qSM_Handler_t 
* argument.
* Unlike a state callback, the surrounding callback should not return anything, 
* thus, the callback should be written as:
*
*  @code{.c}
*  void SurroundingCallback_Example( qSM_Handler_t m ) {
*      switch ( h->Status ) {
*          case qSM_STATUS_BEFORE_ANY:
*              /* TODO: before any code */
*              break;
*          case qSM_STATUS_EXIT_FAILURE:
*              /* TODO: failure code */
*              break;
*          case qSM_STATUS_EXIT_SUCCESS:
*              /* TODO: success code */
*              break;
*          case qSM_STATUS_SIGNAL_HANDLED:
*              /* TODO: signal handled code */
*              break;
*          case 5: /*user defined return value*/
*              /* TODO: used defined*/
*              break;
*          default:
*              /*handle the unexpected*/
*              break
*      }
*  }
*  @endcode 
*
* As you can see in the example below, the surrounding execution case its 
* verified through the FSM handle by reading the @c Status field.
*
* @subsection q_fsm_astask Adding a state machine as a task
* The best strategy to run a FSM is delegating it to a task. For this, the 
* qOS_Add_StateMachineTask() API should be used. Here, the task does not have 
* a specific callback, instead, it will evaluate the active state of the FSM, 
* and later, all the other possible states in response to events that mark 
* their own transition. The task will be scheduled to run every @c t seconds in
* #qPeriodic mode.
*
* By using this API, the kernel will take care of the FSM by itself, so the
* usage of qStateMachine_Run()  can be omitted.
* 
* Now that a task is running a dedicated state-machine, the specific task 
* event-information can be obtained in every state callback through the @c Data
* field of the qSM_Handler_t argument.
*
* Check the example below:
*
*  @code{.c}
*  qSM_Status_t Example_State( qSM_Handler_t h ) {
*      qEvent_t e = h->Data; 
*      /* Get the event info of the task that owns this state-machine*/
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              break;
*          case QSM_SIGNAL_EXIT:
*              break;
*          default:
*              switch ( e->Trigger ) {
*                  case byTimeElapsed:
*                      /* TODO: Code for this case */
*                  break;
*                  case byNotificationSimple:
*                      /* TODO: Code for this case */
*                  break;
*                  case byQueueCount:
*                      /* TODO: Code for this case */
*                  break;
*                  default: break;
*              }
*              /* TODO: State code */
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode 
*
* @subsection q_fsm_example1 A demonstrative example for a FSM 
* In this example, one press of the button turn on the LED, a second push of 
* the button will make the LED blink and if the button is pressed again, the 
* LED will turn off. Also, our system must turn off the LED after a period of 
* inactivity. If the button hasn't been pressed in the last 10 seconds, the 
* LED will turn off.
* 
* <center>
* @htmlonly
* <html>
* <head>
* <title>fsmled</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T16:44:19.377Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;2qA6oxdCwsuBkRDcJq6T\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;rT_7VhNZph5krCK22-1H\&quot; name=\&quot;Página-1\&quot;&gt;7VrbUts6FP2azLQPeOSr5Edyg85wgDacOfSJMbGSaOpYqaJA0q+vZEuOLZtgKAk9TAgD1pa0tb0vS0t2Om5vvj5j0WL2D41x0nFAvO64/Y7j2J4fin9SssklfpC3p4zEasxWMCK/sBICJV2RGC8rAzmlCSeLqnBM0xSPeUUWMUYfq8MmNKmuuoimuCYYjaOkLv2PxHympHYQbjvOMZnO1NLIgXnHPNKD1Z0sZ1FMH0sid9Bxe4xSnl/N1z2cSN9pv+Tzhk/0FoYxnPI2E06cL+TXl68L1D2/+upfuPAyuD6xvVzNQ5Ss1B13nCARCrsTKvQ6wVRea9m9FlxNJlomVrw3xwlZdXrmAL7RXmV0lcZYGgZE9+OMcDxaRGPZ+yjSSMhmfJ6Ili0ul5zRH7hHE8qy2S4C8iNNJElSkg8C+VGmD6M5SWTOnePkAXMyjgpVOpCOGtqkWrkFM47XTzrcLsIo0h/TOeZsI4aoCVDn8EbXAkC54LGUSUANmpWSSKdMpJJ3WujexldcqBC/JNx+U7ijufR4er9cNIVa3K1cuSHY7mkxmJUyoKKuO7q+uxj0766Gw0+fD5QKKU2xmQUXqzGJI7F0j6ZLKhdvSIYoIdNUXCd4oitAIZINDp0rTstc8faWK8EroSE9IsMz0UbIiLbrO7VoO4dFBvhuyHCpgOG5CT9HN2SO2d0I808d6QjVnf/loo+uRGKJ+wc2sIDYoMARcV6Qg7BlDu4PcdDrEKebkPTHEXSeC7jjGVsMBPWAw4OCTnho0Hk1hjQortplrhTjSbSSQ5qtasrVynwykQZqe4cM42+rtMHme5n8YkxuNLD8yefMaDEQtgDVssKnRRqrb67Ozi4GLfG6A/tH7G1ZimHLUkT7KkVd45VSNII3XrGHLHZ2VofxqTxfi+Y4iZZLMq4Grxrp4vALWoSqbSRq+QEAHA6HjcHGa8Jv5fqWr1rflTXyur8uNza6IaHmttzI5liOr9vbeVlLT8w9h+PaowUjQYR36YqN8S6IVJnCIzbF/FkCV0+5Ukb5DQmlZQwnEScPVYObskytcE2J3FB1RofAYBMO9C2/qiW/VzWx/KDC0GUD11Bm+zVluT9qykRKRpvSsIUcsHzabuSZLCioPEURF7nKbWUVvv2DYrM/eLEVhWN5QVguHtsCgfdM9WSta8zEpsYxKxXmben6e6WWm+v3LcswbFuG/nuWITLL0PeNDaN9EdpIAl11m0LC5Wg/heiYlrtgp4EwMCc4h6hcp1a53X9vbq4u766/DUajQT/jXT35m7GogiKVSjv4uaKacJwss9ITHBGgxTonUapb0ypNAQfrBWE43kVbJe0zYESQFF7FCk17WJ59XclkxHEkOVXyOYnjDBkYFsZF95kmWU4qhEKt3+34falqxelSYUcNIjQva6ZqCnJQS4TaExELfN/MOtsKvBoXs4OGmnX3xsXcD749FFwsQF4Jz8XmAOBuRiYa5s7wligP/x8o77kWQgZvQd7rgB7ZgWW7Bs57zr5wPgyBuRbabZ9vTjgIQ6u/Fzvi8B4PxAAaQXbrB+JGEN7bsymn6VXZRwLhEkeHxYE2p9XAKUj7Szh6WyR+L9y0gS84LQxc24co9KBrwp4NLGhobc+XTQIrTj6WE+4FRG0QQAua5NxB2vr9QmPTe8FjYewqjKWIO9c+oMJxWjYkifbC3148AQytsPRj8o/wlQdNCHbq9QBs6n7jggrMl2EeOATJqL9zNQ+TRxbxki9RPPUwr1wi4duQCNHcfnUrT4jt99/cwW8=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Flat FSM example with three states</em>
* </center>
* 
*
* To start the implementation, let's define the necessary global variables...
*
*  @code{.c}
*  qTask_t LED_Task; /*The task node*/
*  qSM_t LED_FSM; /*The state -machine handle*/
*  qSM_State_t State_LEDOff, State_LEDOn, State_LEDBlink;
*  @endcode 
*
* Then, we define our states as the flow-diagram showed in the figure above.
*
*  @code{.c}
*  qSM_Status_t State_LEDOff_Callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              BSP_LED_OFF();
*              break;
*          case QSM_SIGNAL_EXIT: case QSM_SIGNAL_START: /*Ignore*/
*              break;
*          default:
*              if ( BUTTON_PRESSED ) {
*                  h->NextState = &State_LEDOn;
*              }
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t State_LEDOn_Callback( qSM_Handler_t h ) {
*      static qSTimer_t timeout;
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              qSTimer_Set( &timeout, 10.0f ); /*STimer gets armed*/
*              BSP_LED_ON();
*              break;
*          case QSM_SIGNAL_EXIT: case QSM_SIGNAL_START: /*Ignore*/
*              break;
*          default:
*              if ( qSTimer_Expired( &timeout) ) { /*check if the timeout expired*/
*                  h->NextState = &State_LEDOff;
*              }
*              if ( BUTTON_PRESSED  {
*                  h->NextState = &State_LEDBlink;
*              }
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t State_LEDBlink_Callback( qSM_Handler_t h ) {
*      static qSTimer_t timeout; 
*      static qSTimer_t blinktime;
*      
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              qSTimer_Set( &timeout, 10.0f );
*              break;
*          case QSM_SIGNAL_EXIT: case QSM_SIGNAL_START: /*Ignore*/
*              break;
*          default:
*              if ( qSTimer_Expired( &timeout ) || BUTTON_PRESSED ) {
*                  h->NextState = &State_LEDOff;
*              }
*              if ( qSTimer_FreeRun( &blinktime, 0.5f ) ) {
*                 BSP_LED_TOGGLE();
*              }
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode 
*
* Finally, we add the task to the scheduling scheme running the dedicated state 
* machine. Remember that you must set up the scheduler before adding a task to
* the scheduling scheme.
*
*  @code{.c}
*  qStateMachine_Setup( &LED_FSM , NULL , &State_LEDOff , NULL , NULL );
*  qStateMachine_StateSubscribe( &LED_FSM , &State_LEDOff , NULL ,
*                                State_LEDOff_Callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &LED_FSM , &State_LEDOn , NULL ,
*                                State_LEDOn_Callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &LED_FSM , &State_LEDBlink , NULL ,
*                                State_LEDBlink_Callback , NULL , NULL );
*  qOS_Add_StateMachineTask( &LED_Task , &LED_FSM , qHigh_Priority , 0.1f, qEnabled , NULL );
*  @endcode 
*
* @subsection q_fsmsendsignals Sending signals
* To communicate within and between state-machines or even other contexts, use 
* signals. A signal is a simple value who can be used to abstract an incoming 
* event. In the receiving state-machine, a queue or a exclusion variable 
* receives the signal and holds it until the state-machine can evaluate it.
*
* When coding state-machines, the application writer can benefit from this 
* simple event-abstraction mechanism. On the one hand, there would be a more 
* uniform programming when writing states callbacks and on the other hand, the 
* communication of the state machine from other contexts becomes easier.
*
* To send a signal to a state machine, use the qStateMachine_SendSignal() API.
* This API can manage their delivery to one of these possible destinations: 
* an <em>exclusion variable</em> or a <em>signal queue</em>:
* - An <em>exclusion variable</em> its a variable with an important distinction,
* it can only be written if it is empty. The empty situation only happens, if 
* the engine has already propagated the signal within the state machine. If the 
* signal has not yet propagated, the signal sending cannot be carried out.
* - When a <em>signal queue</em> is used, the signal is put into a FIFO structure
* and the engine takes care of dispatching the signal in an orderly manner. The 
* only situation where the signal cannot be delivered is if the queue is full. 
* This its the preferred destination, as long as there is a previously 
* installed signal queue.
*
* @note If the signal-queue its available, the qStateMachine_SendSignal() will
* always select it as destination.
* @warning If a state-machine, a task, or another context sends a signal to a 
* full queue, a queue-overflow occurs. The result of the queue overflow it that
* the state-machine drops the new signal.
* 
* @subsection q_fsminstallsignalqueue Installing a signal queue
* A state machine can have a FIFO queue to allow the delivery of signals from 
* another contexts. If the signal queue its installed, the state-machine engine 
* constantly monitors the queue for available signals. The engine then 
* propagates the signal through the hierarchy until it is processed. To enable 
* this functionality in your state machine, the queue must be installed by using
* the qStateMachine_InstallSignalQueue() API.
*
* The install operation should be performed after both, the queue and the FSM
* are correctly initialized by using qQueue_Setup() and qStateMachine_Setup() 
* respectively.
*
* @note  Make sure that queues are enabled in the @c qconfig.h header file
* @attention When configuring a signal queue with qQueue_Setup(), remember to size
* it based on the type @ref qSM_Signal_t.
* @note If the state-machines its delegated to a task, make sure to install the 
* queue prior to setting up the task. In this way, a kernel connection can be 
* performed between the FSM signal-queue and the FSM-task, allowing the OS to 
* catch signals to produce a task event, this prevents the wait of the task for 
* the specified period, resulting in a faster handling of incoming signals.
*
* @subsection q_fsm_ttable Using a transition table
* In this approach, the FSM is coded in tables with the outgoing transitions of 
* every state, where each entry relates signals, actions and the target state. 
* This is an elegant method to translate the FSM to actual implementation as the 
* handling for every state and event combination is encapsulated in the table.
*
* Here, the application writer get a quick picture of the FSM and the embedded 
* software maintenance is also much more under control. A transition table 
* should be  explicitly installed in the target state with the corresponding 
* entries, an n-sized array of qSM_Transition_t elements following the layout
* described below:
*
* The API qStateMachine_Set_StateTransitions(), should be used to perform the 
* transition table installation to a specific state.
*
* <center>
* <table>
* <caption id="multi_row">Transition table layout for a state</caption>
* <tr><th>Signal Id <th>Signal action/guard <th>Target state  <th>History mode  <th>Signal data
* <tr><td> @c Signal1 <td>@c NULL <td>@c StateB <td>@c 0 <td>@c NULL
* <tr><td> @c Signal3 <td>@c DoOnSignal3 <td>@c StateD <td>@c 0 <td>@c &sig3data
* <tr><td> ... <td>... <td> ... <td> ... <td> ...
* <tr><td> @c Signal6 <td>@c NULL <td>@c StateA <td>@c 0 <td>@c NULL
* </table>
* </center>
*
* <b> Caveats: </b>
*
* - State transitions are not limited to the specification of the transition 
* table. A state callback owns the higher precedence to change a state. The 
* application writer can use both, a transition table and direct @c NextState 
* field manipulation in state callbacks to perform a transition to the FSM.
* - Special care is required when the table grows very large, that is, when 
* there are many invalid state/event combinations, leading to a waste of memory. 
* There is also a memory penalty as the number of states and events grow. The 
* application writer need to accurately account for this during initial design. 
* A statechart pattern can be used to improve the design and reduce the number 
* of transition entries.
* - The user is responsible for defining the transitions according to the 
* topology of the state machine. Undefined behaviors can occur if the topology 
* is broken with poorly defined transitions.
*
* @subsection q_fsm_sigactions Signal actions and guards
* Transition tables allow the usage of this feature. When an event-signal is 
* received from the queue, the signal-action, if available, is evaluated before 
* the transition is triggered. This action is user-defined and should be coded 
* as a function that takes a qSM_Handler_t object and returns a value of type 
* @ref qBool_t.
*
*  @code{.c}
*  qBool_t Signal_Action( qSM_Handler_t h ) {
*      /* TODO : Event -signal action*/
*      return qTrue; /*allow the state transition*/
*  }
*  @endcode 
*
* The return value is checked after to allow or reject the state transition. The
* application writer can code a boolean expression to implement 
* <em>statechart guards</em> or perform some pre-transition procedure.
* 
* @remark If a signal-action returns \ref qFalse, the event-signal is rejected, 
* preventing the state transition to be performed in the calling FSM.
* @note When a transition entry is defined. the signal-action should be located
* as the third parameter of the entry. Please see the transition layout. A
* @c NULL value will act as a NOT-defined, always allowing the state-transition.
*
* @subsection q_fsm_timeout FSM Timeout specification
* A timeout specification is mechanism to simplify the notion of time passage
* inside states. The basic usage model of the timeout signals is as follows:
*
* A timeout specification allocates one or more timer objects. The user relates
* in a table each specific timeout operations within the state where are they 
* going to operate. So, according to the table, when a state needs to arrange 
* for a timeout, the engine can set or reset the given timer. When the FSM 
* engine detects that the appropriate moment has arrived (a timer expiration 
* occurs), it inserts the timeout signal directly into the recipient's event 
* queue. The recipient then processes the timeout signal just like any other 
* signal.
*
* Given the above explanation, it is evident that for its operation, the state 
* machine requires an installed signal queue.
* A timeout specification is referenced by an object of type qSM_TimeoutSpec_t 
* and must be installed inside the state machine using the API 
* qStateMachine_InstallTimeoutSpec(). Then, timeout operations can be defined 
* in a table for each state by using the qStateMachine_Set_StateTimeouts().
*
* A timeout specification element is defined as an structure of type 
* qSM_TimeoutStateDefinition_t and should follow this layout:
*
* <center>
* <table>
* <caption id="multi_row">Timeout specification layout</caption>
* <tr><th>Timeout value  <th>Options
* </table>
* </center>
*
* The options for every timeout its a bitwise value that indicates which timeout
* should be used and the operations than should be performed internally by the 
* state-machine engine. This options can be combined with a bitwise OR and are 
* detailed as follows:
*
* - #QSM_TSOPT_INDEX(index) : To select the timeout to be used in the 
* specification. Should be a value between @c 0 and @c Q_FSM_MAX_TIMEOUTS-1 
* - #QSM_TSOPT_SET_ENTRY : To set the timeout when the specified state its 
* entering.
* - #QSM_TSOPT_RST_ENTRY : To reset the timeout when the specified state its 
* entering.
* - #QSM_TSOPT_SET_EXIT : To set the timeout when the specified state its exiting.
* - #QSM_TSOPT_RST_EXIT : To reset the timeout when the specified state its 
* exiting.
* - #QSM_TSOPT_KEEP_IF_SET : To apply the Set operation only if the timeout its 
* in a reset state.
* - #QSM_TSOPT_PERIODIC : To put the timeout in periodic mode.
* 
* @note Data associated to timeout signals should be set to @c NULL. Any other
* value will be ignored and will be passed as @c NULL to the FSM handler.
* @attention The user is responsible for writing timeout specifications 
* correctly. Care must be taken that the specifications do not collide between 
* hierarchical states to avoid overwriting operations.
* @note You can increase the number of available timeouts instances by changing 
* the @c Q_FSM_MAX_TIMEOUTS configuration macro inside @c qconfig.h.
* 
* @subsection q_fsm_example2 Demonstrative example using transition tables 
* The following example shows the implementation of the led-button FSM presented
* above by using the transition table approach with signal-queue and a timeout 
* specification.
* 
* Before getting started, the required variables should be defined:
*
*  @code{.c}
*  /*define the FSM application event-signals*/
*  #define SIGNAL_BUTTON_PRESSED   ( (qSM_SigId_t)1 )
*  #define SIGNAL_TIMEOUT          ( QSM_SIGNAL_TIMEOUT(0) )
*  #define SIGNAL_BLINK            ( QSM_SIGNAL_TIMEOUT(1) )
*  
*  qTask_t LED_Task; /*The task node*/
*  qSM_t LED_FSM; /*The state-machine handler*/
*  qSM_State_t State_LEDOff, State_LEDOn, State_LEDBlink;
*  qQueue_t LEDsigqueue; /*the signal-queue*/ 
*  qSM_Signal_t led_sig_stack[ 5 ];  /*the signal-queue storage area*/
*  qSM_TimeoutSpec_t tm_spectimeout;
*  
*  /*create the transition tables for every state*/
*  qSM_Transition_t LEDOff_transitions[] = {
*      { SIGNAL_BUTTON_PRESSED, NULL, &State_LEDOn    , 0, NULL}
*  };
*  
*  qSM_Transition_t LEDOn_transitions[] = {
*      { SIGNAL_TIMEOUT,        NULL, &State_LEDOff   , 0, NULL},
*      { SIGNAL_BUTTON_PRESSED, NULL, &State_LEDBlink , 0, NULL}
*  };
*  
*  qSM_Transition_t LEDBlink_transitions[] = {
*      { SIGNAL_TIMEOUT,        NULL, &State_LEDOff   , 0, NULL},
*      { SIGNAL_BUTTON_PRESSED, NULL, &State_LEDOff   , 0, NULL}
*  };
*  
*  /*define the timeout specifications */
*  qSM_TimeoutStateDefinition_t LedOn_Timeouts[] = {
*      { 10.0f,  QSM_TSOPT_INDEX(0) | QSM_TSOPT_SET_ENTRY | QSM_TSOPT_RST_EXIT  },
*  };
*  
*  qSM_TimeoutStateDefinition_t LEDBlink_timeouts[] = {
*      { 10.0f,  QSM_TSOPT_INDEX(0) | QSM_TSOPT_SET_ENTRY | QSM_TSOPT_RST_EXIT  },
*      { 0.5f,   QSM_TSOPT_INDEX(1) | QSM_TSOPT_SET_ENTRY | QSM_TSOPT_RST_EXIT | QSM_TSOPT_PERIODIC  }
*  };
*  @endcode 
*
* Then, we define the callback for the states.
* 
*  @code{.c}
*  qSM_Status_t State_LEDOff_Callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              BSP_LED_OFF();
*              break;
*          default:
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t State_LEDOn_Callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              BSP_LED_ON();
*              break;
*          default:
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t State_LEDBlink_Callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case SIGNAL_BLINK:
*              BSP_LED_TOGGLE();
*              break;
*          default:
*              break;
*      }
*      return qSM_STATUS_EXIT_SUCCESS;
*  }
*  @endcode 
* 
* In the previous code snippet, we assumed that @c SIGNAL_BUTTON_PRESSED can be
* delivered from either the interrupt context or another task.
*
* To finish the setup, a task is added to handle the FSM and then, the 
* transition table can be installed with the other required objects.
*
*  @code{.c}
*  qStateMachine_Setup( &LED_FSM, NULL, &State_LEDOff, NULL, NULL );
*  qStateMachine_StateSubscribe( &LED_FSM, &State_LEDOff, QSM_STATE_TOP, State_LEDOff_Callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &LED_FSM, &State_LEDOn, QSM_STATE_TOP, State_LEDOn_Callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &LED_FSM, &State_LEDBlink, QSM_STATE_TOP, State_LEDBlink_Callback, NULL, NULL );
*  
*  qQueue_Setup( &LEDsigqueue, led_sig_stack, sizeof(qSM_Signal_t), qFLM_ArraySize(led_sig_stack) );
*  qStateMachine_InstallSignalQueue( &LED_FSM, &LEDsigqueue );
*  
*  qStateMachine_InstallTimeoutSpec( &LED_FSM, &tm_spectimeout );
*  qStateMachine_Set_StateTimeouts( &State_LEDOn, LedOn_Timeouts, qFLM_ArraySize(LedOn_Timeouts) );
*  qStateMachine_Set_StateTimeouts( &State_LEDBlink, LEDBlink_timeouts, qFLM_ArraySize(LEDBlink_timeouts) );
*  
*  qStateMachine_Set_StateTransitions( &State_LEDOff, LEDOff_transitions, qFLM_ArraySize(LEDOff_transitions) );
*  qStateMachine_Set_StateTransitions( &State_LEDOn, LEDOn_transitions, qFLM_ArraySize(LEDOn_transitions) );
*  qStateMachine_Set_StateTransitions( &State_LEDBlink, LEDBlink_transitions, qFLM_ArraySize(LEDBlink_transitions) );
*  
*  qOS_Add_StateMachineTask( &LED_Task, &LED_FSM, qMedium_Priority, 0.1f, qEnabled, NULL );
*  @endcode 
*
* @subsection qfsm_happroach Using the hierarchical approach
* In conventional state machine designs, all states are considered at the same 
* level. The design does not capture the commonality that exists among states. 
* In real life, many states handle most transitions in similar fashion and 
* differ only in a few key components. Even when the actual handling differs, 
* there is still some commonality. It is in these situations where the 
* hierarchical designs makes the most sense.
* 
* A hierarchical state-machine is characterized by having compound states. A 
* composite state is defined as state that has inner states and can be used as a
* decomposition mechanism that allows factoring of common behaviors and their 
* reuse. And this is the biggest advantage of this design, because it captures
* the commonality by organizing the states as a hierarchy. The states at the 
* higher level in hierarchy perform the common handling, while the lower level 
* states inherit the commonality from higher level ones and perform the state 
* specific functions.
* 
* @subsubsection q_fsm_example3 Example usign a hierarchical FSM
* This example takes the "Cruise Control" study case, a real-time system that
* manages the speed of an automobile based on inputs from the driver.
* 
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>hsm</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T16:51:35.501Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;QdIZd3r2DwtN3vC1hyVB\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;Ucjj-E1xw4AO6E8yxrXi\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Cruise control FSM example</em>
* </center>
*
* The behavior of this system is state-dependent in that the executed actions
* correspond not only to the driver input, but also on the current state of the 
* system and with the status of the engine and the brake.
* The figure above illustrate the modeling of this system with the 
* "Automated Control" state acting as composite.
*
* Before getting started, the required user-defined signals, variables, and 
* entries of the transition table should be defined:
* 
*  @code{.c}
*  #define  SIGNAL_ENGINE_ON           ( (qSM_SigId_t)(1) )
*  #define  SIGNAL_ACCEL               ( (qSM_SigId_t)(2) )
*  #define  SIGNAL_RESUME              ( (qSM_SigId_t)(3) )
*  #define  SIGNAL_OFF                 ( (qSM_SigId_t)(4) )
*  #define  SIGNAL_BRAKE_PRESSED       ( (qSM_SigId_t)(5) )
*  #define  SIGNAL_CRUISE              ( (qSM_SigId_t)(6) )
*  #define  SIGNAL_REACHED_CRUISING    ( (qSM_SigId_t)(7) )
*  #define  SIGNAL_ENGINE_OFF          ( (qSM_SigId_t)(8) )
*  
*  qTask_t CruiseControlTask;
*  qSM_t Top_SM;
*  
*  /*highest level states*/
*  qSM_State_t state_idle, state_initial, state_cruisingoff, state_automatedcontrol;
*  /*states inside the state_automatedcontrol*/
*  qSM_State_t state_accelerating, state_cruising, state_resuming;
*  
*  qQueue_t top_sigqueue;
*  qSM_Signal_t topsm_sig_stack[ 10 ];
*  
*  /*=======================================================================*/
*  /*                             TRANSITION TABLES                         */
*  /*=======================================================================*/
*  qSM_Transition_t idle_transitions[] =
*  {
*  { SIGNAL_ENGINE_ON, SigAct_ClearDesiredSpeed, &state_initial      , 0, NULL }
*  };
*  
*  qSM_Transition_t initial_transitions[] =
*  {
*  { SIGNAL_ACCEL,     SigAct_BrakeOff,          &state_accelerating , 0, NULL }
*  };
*  
*  qSM_Transition_t accel_transitions[] =
*  {
*  { SIGNAL_CRUISE,     NULL,                    &state_cruising     , 0, NULL }
*  };
*  
*  qSM_Transition_t cruising_transitions[] =
*  {
*  { SIGNAL_OFF,       NULL,                     &state_cruisingoff  , 0, NULL },
*  { SIGNAL_ACCEL,     NULL,                     &state_accelerating , 0, NULL }
*  };
*  
*  qSM_Transition_t resuming_transitions[] =
*  {
*  { SIGNAL_ACCEL,      NULL,                    &state_accelerating , 0, NULL }
*  };
*  
*  qSM_Transition_t cruisingoff_transitions[] =
*  {
*  { SIGNAL_ACCEL,      SigAct_BrakeOff,         &state_accelerating , 0, NULL },
*  { SIGNAL_RESUME,     SigAct_BrakeOff,         &state_resuming     , 0, NULL },
*  { SIGNAL_ENGINE_OFF, NULL,                    &state_idle         , 0, NULL }
*  };
*  
*  qSM_Transition_t automated_transitions[] =
*  {
*  { SIGNAL_BRAKE_PRESSED,   NULL,               &state_cruisingoff  , 0, NULL }
*  };
*  /*---------------------------------------------------------------------*/
*  @endcode 
*
* Then, signal-actions and state callbacks are later defined
*
*  @code{.c}
*  /*=======================================================================*/
*  /*                      EVENT-SIGNAL ACTIONS AND GUARDS                  */
*  /*=======================================================================*/
*  qBool_t SigAct_ClearDesiredSpeed( qSM_Handler_t h ) {
*      (void)h;
*      Speed_ClearDesired();
*      return qTrue;
*  }
*  /*---------------------------------------------------------------------*/
*  qBool_t SigAct_BrakeOff( qSM_Handler_t h ) {
*      (void)h; /*unused*/
*      return ( BSP_BREAK_READ() == OFF )? qTrue : qFalse;  /*check guard*/
*  }
*  /*=======================================================================*/
*  /*                  STATE CALLBACK FOR THE TOP FSM                      */
*  /*=======================================================================*/
*  qSM_Status_t state_top_callback( qSM_Handler_t h ) {
*      qSM_Status_t RetVal = qSM_STATUS_EXIT_SUCCESS;
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_ENTRY:
*              break;
*          case QSM_SIGNAL_EXIT:
*              break;
*      } 
*      return RetVal;
*  }
*  /*=======================================================================*/
*  /*                  CALLBACKS FOR THE STATES ABOVE TOP                    */
*  /*=======================================================================*/
*  qSM_Status_t state_idle_callback( qSM_Handler_t h ) {
*      /*TODO : state activities*/
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_initial_callback( qSM_Handler_t h ) {
*      /*TODO : state activities*/
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_cruisingoff_callback( qSM_Handler_t h ) {
*      /*TODO : state activities*/
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_automatedcontrol_callback( qSM_Handler_t h ) {
*      /*TODO : state activities*/
*      return qSM_EXIT_SUCCESS;
*  }
*  /*=======================================================================*/
*  /*          STATE CALLBACKS FOR THE AUTOMATED CONTROL FSM                */
*  /*=======================================================================*/
*  qSM_Status_t state_accelerating_callback( qSM_Handler_t h ) {
*      switch ( h->Signal ) {
*          case QSM_SIGNAL_EXIT:
*              Speed_SelectDesired();
*              break;
*          default:
*              Speed_Increase();
*              break;
*      }
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_resuming_callback( qSM_Handler_t h ) {
*      Cruising_Resume();
*      return qSM_EXIT_SUCCESS;
*  }
*  /*---------------------------------------------------------------------*/
*  qSM_Status_t state_cruising_callback( qSM_Handler_t h ) {
*      Speed_Maintain();
*      return qSM_EXIT_SUCCESS;
*  }
*  
*  @endcode
*
* Finally, the dedicated task for the FSM and related objects are configured.
*
*  @code{.c}
*  qStateMachine_Setup( &Top_SM, state_top_callback, &state_idle, NULL, NULL );
*  /*subscribe to the highest level states*/
*  qStateMachine_StateSubscribe( &Top_SM, &state_idle, QSM_STATE_TOP, state_idle_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_initial, QSM_STATE_TOP, state_initial_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_cruisingoff, QSM_STATE_TOP, state_cruisingoff_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_automatedcontrol, QSM_STATE_TOP, state_automatedcontrol_callback, NULL, NULL );
*  /*subscribe to the states within the state_automatedcontrol*/
*  qStateMachine_StateSubscribe( &Top_SM, &state_accelerating, &state_automatedcontrol, state_accelerating_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_resuming, &state_automatedcontrol, state_resuming_callback, NULL, NULL );
*  qStateMachine_StateSubscribe( &Top_SM, &state_cruising, &state_automatedcontrol, state_cruising_callback, NULL, NULL );
*  
*  qQueue_Setup( &top_sigqueue, topsm_sig_stack, sizeof(qSM_Signal_t), qFLM_ArraySize(topsm_sig_stack) );
*  qStateMachine_InstallSignalQueue( &Top_SM, &top_sigqueue );
*  
*  qStateMachine_Set_StateTransitions( &state_idle, idle_transitions, qFLM_ArraySize(idle_transitions) );
*  qStateMachine_Set_StateTransitions( &state_initial, initial_transitions, qFLM_ArraySize(initial_transitions) );
*  qStateMachine_Set_StateTransitions( &state_cruisingoff, cruisingoff_transitions, qFLM_ArraySize(cruisingoff_transitions) );
*  qStateMachine_Set_StateTransitions( &state_automatedcontrol, automated_transitions, qFLM_ArraySize(automated_transitions) );
*  qStateMachine_Set_StateTransitions( &state_accelerating, accel_transitions, qFLM_ArraySize(accel_transitions) );
*  qStateMachine_Set_StateTransitions( &state_resuming, resuming_transitions, qFLM_ArraySize(resuming_transitions) );
*  qStateMachine_Set_StateTransitions( &state_cruising, cruising_transitions, qFLM_ArraySize(cruising_transitions) );
*  
*  qOS_Add_StateMachineTask(  &CruiseControlTask, &Top_SM, qMedium_Priority, 0.1f, qEnabled, NULL );
*  @endcode
* 
* @subsubsection q_fsm_example4 Example with history pseudo-states
* State transitions defined in high-level composite states often deal with 
* events that require immediate attention; however, after handling them, the 
* system should return to the most recent substate of the given composite state.
* UML statecharts address this situation with two kinds of history pseudostates:
* @a "shallow history" and @a "deep history"( denoted as the circled @c H and 
* @c H* icon respectively in figure).
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>fsmhist</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T18:43:21.516Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;Ch7yXC-GbSBqROWlSNdq\&quot; version=\&quot;20.4.1\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;sgRdDsJHhmN2pV4VL9Bt\&quot; name=\&quot;Página-1\&quot;&gt;7Vtbb+o4EP41vKzUKLbjXB4bWrYr7UpH6sOe87TKIS5YJ8QoMS3tr18bbHKxUQM9AUoDEoonyRjP92VmPHZGaLxY/1kky/k/LCXZCLrpeoTuRhBi6ItfKXjdCm5QEG4ls4KmWxmoBI/0jSihq6QrmpKycSFnLON02RROWZ6TKW/IkqJgL83LnljW7HWZzIgheJwmmSn9l6Z8rqTAj6oTD4TO5qrrEAbbE4tEX6xGUs6TlL3UROh+hMYFY3x7tFiPSSaNp+2yvW+y5+zujxUk511u8P5b+GGcv/21uP1RrPO3+/U4vlFanpNspQas/ix/1RYo2CpPiVTijlD8MqecPC6TqTz7IjAXsjlfZKIFxGHJC/aLjFnGis3dKHTlV5x5olmm5TnLiRSxnE+SBc0kOf5eTWmaiK7HLC+Z7Fwp02YXBouTjM5ycZyRJ64UKMoAV7VtfatBkoKT9V7rgR0mgsyELQgvXsUl6gYUKRgVkQF0PQcqLr/UmKHhntdIAYDneJ4ipSLkbNdFhZk4ULAdACG0QOhn0jw/xcFMHjzyhBOsxaKX3ZlToC3k9778tiF/INkz4XSaWLHuEUwPBC0wgRVMLzSx1Pj+dhxRRxz9Acf9OAb+eUH0Bn96LHRRN+hAX9Dh96EjeXorcwrRmmZJWdJpE60mtLuA73bA5h3Tx5uvjRCuG0wmEyu6JU8Krv+w4shGNqHSNJv/JYakWnIAZE35d3nGiVyk2j9E+8Z1XAHYVnC31vfKxmut8Y0UVIBBCiXbGpCkRor1LktqJMCWgKplBckSTp+b6m3MUD18Y1R0XJHQEwMF7u4DWpT0oBOhaPcJm/pLtiqmRKmsJ16WXoJaLzonNpyWViwgmhFuKBZIJq+1y5bygtLg/c6Kxz8K/uDFjvViqHMi0ZsjC0z0cDwZ4TsDRDFw3kSqZUppHBHXs1slXtA03YBQkJK+JT83iqQtFReFVhzLnoSmFWelQsGggIbajr4CL+zoNvvC1sNtdxBZsbX4p97yi/C6gxQTA2sFKWAGqVxY8nu98WMTsrBuVgFq09IR6uKjUdQmHEROFB0ZdPwOys4eaCILnW1zHm+Y8+wtRICweyGiN7+kg9m7SKIByR2S7gVWIcBQETwavgvI/YCtGnhFCUKnWeylB3qEjdgcOQE8LtCjCDhu7QPbpGxR7ewxH9gKnVdE0S+dwyLQKm6AMDye2m1lECAnAJfGZ1vN15b6wCH1qWJnO4nF0AicMDhpBmvWfx9Mv5RldFmSPoCx2/9R9Q36xQNDIxVFju+ZkNgWN6O+EDHLkA9/fGFIPMsjclI8LIXFYWrQzb0FHd0bwL4RLn8fgLbqoS1SgSFSaSj9NpTQtVeBTzpJt9XNhiexE3ywM3xR1OOmHVu97IomQd1Wm690EmSSDoOjJ0HYa+cBGDog2rsqffb5EOxQQfzM1P7S83sfeo29DKiV58i1iCNXrN5RXY+7l8P1odx6PNf1ZiO5uQh7o2q3kev4eHRte42wTCfcoPLbLXqHwPGA3y7jHhwtdHmsrlcvVFzOY2MpAeP4ftiicug8028nGsA9+xYV2GEP7OATP2v8N/ZIQviB1DZsK0OXndpa9gjj+HbwW4fWNoP2Aqj9ZZrT+i3LrlccxwO4HwZ3z76Ik4Jr3RQ7HsD9MLg4dPCZsT1sU6yy6SfJNqr0aH/BYZdGDJOwj03CEIC9TMKk3subhFkWEXB8N7jEg12i8SYb6Mshimb1wviWCNVr9+j+fw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Example with history pseudo-states</em>
* </center>
* 
* - @a Shallow @a history :  A transition to the shallow history state in a 
* composite state invokes the last state that was active, at the same depth as 
* the history state itself, prior to the most recent exit of the composite state.
* - @a Deep @a history :  A transition to the deep history state within a 
* composite state invokes the state that was active, immediately before the most
* recent exit of the composite state. The last active state can be nested at any
* depth.
* 
* Here, the way to specify this type of transitions in QuarkTS is very 
* straightforward, you only need to assign the history-mode in the last entry 
* of the transition as shown below:
*
*  @code{.c}
*  #define SIGNAL_A ( (qSM_SigId_t)(1) )
*  #define SIGNAL_B ( (qSM_SigId_t)(2) )
*  #define SIGNAL_C ( (qSM_SigId_t)(3) )
*  #define SIGNAL_D ( (qSM_SigId_t)(4) )
*  #define SIGNAL_E ( (qSM_SigId_t)(5) )
*  #define SIGNAL_F ( (qSM_SigId_t)(6) )
*
*  qQueue_t sigqueue;
*  qSM_Signal_t topsm_sig_stack[ 10 ];
*  qSM_t super;
*  qSM_State_t state1 , state2 , state3 , state4 , state5 , state6;
*
*  qSM_Transition_t state1_transitions [] = {
*      { SIGNAL_A , NULL , &state2 , qSM_TRANSITION_SHALLOW_HISTORY, NULL },
*      { SIGNAL_B , NULL , &state2 , qSM_TRANSITION_DEEP_HISTORY, NULL },
*      { SIGNAL_C , NULL , &state2 , qSM_TRANSITION_NO_HISTORY, NULL }
*  };
*
*  qSM_Transition_t state2_transitions [] = {
*      { SIGNAL_D , NULL , &state1 , 0, NULL }
*  };
*
*  qSM_Transition_t state3_transitions [] = {
*      { SIGNAL_E , NULL , &state4 , 0, NULL }
*  };
*
*  qSM_Transition_t state5_transitions [] = {
*      { SIGNAL_F , NULL , &state6 , 0, NULL }
*  };
*  @endcode
*
* Next, the configuration and topology of the state-machine is presented,
* including the default transitions (the small circles filled with black).
* Please do not forget to define the callbacks for each state.
*
*  @code{.c}
*  qStateMachine_Setup( &super , state_top_callback , &state1 , NULL , NULL );
*  qStateMachine_StateSubscribe( &super , &state1 , QSM_STATE_TOP , state1_callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &super , &state2 , QSM_STATE_TOP , state2_callback , &state3 , NULL );
*  qStateMachine_StateSubscribe( &super , &state3 , &state2 , state3_callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &super , &state4 , &state2 , state4_callback , &state5 , NULL );
*  qStateMachine_StateSubscribe( &super , &state5 , &state4 , state5_callback , NULL , NULL );
*  qStateMachine_StateSubscribe( &super , &state6 , &state4 , state6_callback , NULL , NULL );
*
*  qQueue_Setup( &sigqueue , topsm_sig_stack , sizeof(qSM_Signal_t), qFLM_ArraySize(topsm_sig_stack ) );
*  qStateMachine_InstallSignalQueue( &super , &sigqueue );
*  qStateMachine_Set_StateTransitions( &state1 , state1_transitions , qFLM_ArraySize( state1_transitions ) );
*  qStateMachine_Set_StateTransitions( &state2 , state2_transitions , qFLM_ArraySize( state2_transitions ) );
*  qStateMachine_Set_StateTransitions( &state3 , state3_transitions , qFLM_ArraySize( state3_transitions ) );
*  qStateMachine_Set_StateTransitions( &state5 , state5_transitions , qFLM_ArraySize( state5_transitions ) );
*  qOS_Add_StateMachineTask( &SMTask , &super , qMedium_Priority , 0.1f, qEnabled , NULL );
*  @endcode 
* 
* @section q_qcoroutines Co-Routines
* A task coded as a Co-Routine, is just a task that allows multiple entry points
* for suspending and resuming execution at certain locations, this feature can 
* bring benefits by improving the task cooperative scheme and providing a linear
* code execution for event-driven systems without complex state machines or full
* multithreading.
* 
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>coroutines</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T18:53:51.655Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;TUBuhUjvMgM2ZADYfpx0\&quot; version=\&quot;20.4.1\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;9UbcoEgD98S6Um2omTv-\&quot; name=\&quot;Página-1\&quot;&gt;7Vhdb5swFP01PC4yEELy2NBk1bpO1TJp614mB1ywauzMOF/79bsOhmBI0mZVtapqeIjvse+9vj72scDxo3zzUeJFdiMSwhwPJRvHv3Q8z3VRAH8a2VbIoARSSRMD7YEZ/UMMiAy6pAkprIFKCKbowgZjwTmJlYVhKcXaHnYvmJ11gVPSAWYxZl30O01UVlcx2ndcEZpmJvXQC8uOHFeDTSVFhhOxbkD+xPEjKYQqW/kmIkwvXrUupd/0SG89MUm4eorDdZwOiPfz+svlchV94jdzMbr9YKKsMFuagh1vgPOF44/5vNB/v6Ovv8YkpRyGOeEYuhmkG88ltFLdajvocY9DvV7vFYbSxd5RovfIe6UvNL0QdhnS6Se8TL47HGpbnTgpljwhetMi6F5nVJHZAse6dw0aA1imcgaWC81CSfFAIsGE3Hn7CIXTKRyB8T1lrMK54ERDgqspzinTWvR5GdMEQ+pI8ELo5CZYdcw949EIPkT6MfjMTLm2S+1ytY0ZTTkYjNyrusYVkYpsjp5et9YEEFMicqLkFoYYh6FRESOjo8DI6LohSmhYYllDj1yvb8TQCGFah95rBTSMXJwhHV5HOr7h4gGQi+dR2iQO1jyKJkFJ6BEuTm+BiiWgWFdj74ErwlZE0RgfJb9yd1+Awj56IoWDF2LQfxf/N6eubz7U+/XxL9rj9Uev7f7oH7s/nsnpm70/Ohz+9wskOHCBtKgjPLnQr2FgzZmIH75lcJlYfNnk1m9J6Aknrn1uWhSPd88hilvkV6yVkoClqqYsoLQKm1JWTRmKalobqn402nd69r0wMOblxlSzM7bGKBeKJJ23z0d3Q4PtAHXJrjBJGFZ0ZYc/tANMhltBIXG92dxw2EONn+fbey90e31/VP+GdvxCLGVMTMjmO2k3ixXWRSGyI8HKp0R1IgFBeNsYttADipPltBIhdHJmXjBsF3zWeBe5pxN0Z3S2Q/+8ElzU/kLwqMPg3CkFlgM0SqL2ElNv5EOqA+b+e0g5fP9VyZ/8BQ==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Coroutines in QuarkTS</em>
* </center>
* 
* The QuarkTS implementation uses the Duff's device approach, and is heavily
* inspired by the Knuth method, <a style="font-weight:bold" href="https://www.chiark.greenend.org.uk/~sgtatham/coroutines.html">Simon Tatham's Co-Routines in C</a>
* and <a style="font-weight:bold" href="http://dunkels.com/adam/pt/index.html">Adam Dunkels Protothreads</a>
* . This means that a local-continuation variable is used to preserve the current
* state of execution at a particular place of the Co-Routine scope but without 
* any call history or local variables. This brings benefits to lower RAM usage, 
* but at the cost of some restrictions on how a Co-routine can be used.
*
* <b> Limitations and restrictions </b>
*
* - The stack of a Co-Routine is not maintained when a yield is performed. This
* means variables allocated on the stack will loose their values. To overcome 
* this, a variable that must maintain its value across a blocking call must be 
* declared as @c static.
* - Calls to API functions that could cause the Co-Routine to block, can only 
* be made from the Co-Routine function itself - not from within a function
* called by the Co-Routine.
* - The implementation does not permit yielding or blocking calls to be made from
* within a @c switch statement.
*
* @subsection q_coroutine_code Coding a Co-Routine
* The application writer just needs to create the body of the Co-Routine . This
* means starting a Co-Routine segment with #qCR_Begin and end with #qCR_End 
* statement . From now on, yields and blocking calls from the Co-Routine scope 
* are allowed.
*
*  @code{.c}
*  void CoroutineTask_Callback( qEvent_t e ) {
*      qCR_Begin {
*          if ( EventNotComing() ) {
*              qCR_Yield;
*          }
*          DoTheEventProcessing();
*          qCR_Delay( WAIT_TIME_S );
*          PerformActions();
*      } qCR_End;
*  }
*  @endcode
*
* The #qCR_Begin statement should be placed at the start of the task function 
* in which the Co-routine runs. All C statements above the #qCR_Begin will be 
* executed as if they were in an endless-loop each time the task is scheduled.
*
* A #qCR_Yield statement return the CPU control back to the scheduler but saving
* the  execution progress, thereby allowing other processing tasks to take place
* in the system. With the next task activation, the Co-Routine will resume the
* execution after the last #qCR_Yield statement.
*
* @note Co-Routine statements can only be invoked from the scope of the 
* Co-Routine.
* @remark Do not use an endless-loop inside a Co-routine ,this behavior it's 
* already hardcoded within the segment definition.
*
* @subsection q_coroutine_blocking Blocking calls in a Co-routine
* Blocking calls inside a Co-Routine should be made with the provided
* statements, all of them with a common feature: an implicit yield.
*
* A widely used procedure is to wait for a fixed period of time. For this, the 
* #qCR_Delay should be used. This statement makes an apparent blocking over the
* application flow, but to be precise, a yield is performed until the requested 
* time expires, this allows other tasks to be executed until the blocking call 
* finish. This "yielding until condition meet" behavior its the common pattern 
* among the other blocking statements.
*
* Another common blocking call is #qCR_WaitUntil. This statement takes a 
* condition argument, a logical expression that will be performed when the 
* Co-Routine resumes their execution. As mentioned before, this type of 
* statement exposes the expected behavior, yielding until the condition is met.
*
* An additional wait statement #qCR_TimedWaitUntil is also provided. This one
* sets a timeout for the logical condition to be met, with a similar behavior 
* of #qCR_WaitUntil.
*
* Optionally, the Do-Until structure gives to application writer the ability to 
* perform a multi-line job before the yield, allowing more complex actions to
* being performed after the Co-Routine resumes:
*
*  @code{.c}
*  qCR_Do{
*      /* Job : a set of instructions*/
*  } qCR_Until( Condition );
*  @endcode
*
* @subsection q_coroutine_example1 Co-Routine usage example
*
*  @code{.c}
*  void Sender_Task( qEvent_t e ) {
*      static qSTimer_t timeout;
*      qCR_Begin {
*          Send_Packet();
*          /* Wait until an acknowledgment has been received, or until
*           * the timer expires. If the timer expires, we should send
*           * the packet again.
*           */
*          qSTimer_Set( &timeout, TIMEOUT_TIME );
*          qCR_WaitUntil( PacketACK_Received() || qSTimer_Expired(&timeout));
*      }qCR_End;
*  }
*  /*===================================================================*/
*  void Receiver_Task( qEvent_t e ) {
*      qCR_Begin {
*          /* Wait until a packet has been received*/
*          qCR_WaitUntil( Packet_Received() );
*          Send_Acknowledgement();
*      } qCR_End;
*  }
*  @endcode
*
* @subsection q_coroutine_positions Positional jumps
* This feature provides positional local jumps, control flow that deviates from 
* the usual Co-Routine call.
*
* The complementary statements #qCR_PositionGet and #qCR_PositionRestore provide
* this
* functionality. The first one saves the Co-Routine state at some point of their 
* execution into @c CRPos, a variable of type @ref qCR_Position_t , that can be used
* at some later point of program execution by #qCR_PositionRestore to restore 
* the Co-Routine state to the one saved by #qCR_PositionGet into CRPos. This 
* process can be imagined to be a "jump" back to the point of program execution 
* where #qCR_PositionGet saved the Co-Routine environment.
* 
* @subsection q_coroutine_semaphores Semaphores
* This extension implements counting semaphores on top of Co-Routines. 
* Semaphores are a synchronization primitive that provide two operations: @a wait 
* and @a signal. The @a wait operation checks the semaphore counter and blocks 
* the Co-Routine if the counter is zero. The @a signal operation increases the 
* semaphore counter but does not block. If another Co-Routine has blocked 
* waiting for the semaphore that is signaled, the blocked Co-Routines will
* become runnable again.
*
* Semaphores are referenced by handles, a variable of type qCR_Semaphore_t and 
* must be initialized with #qCR_SemInit before any usage. Here, a value for the
* counter is required. Internally, semaphores use an @c uint32_t to represent 
* the counter, therefore the value argument should be within range of this 
* data-type.
* 
* To perform the |a wait operation, the #qCR_SemWait statement should be used. 
* The wait operation causes the Co-routine to block while the counter is zero. 
* When the counter reaches a value larger than zero, the Co-Routine will 
* continue.
* 
* Finally, #qCR_SemSignal carries out the @a signal operation on the semaphore. 
* This signaling increments the counter inside the semaphore, which eventually 
* will cause waiting Coroutines to continue executing.
*
* @subsection q_coroutine_example2 Co-Routine example with semaphores.
* The following example shows how to implement the bounded buffer problem using
* Co-Routines and semaphores. The example uses two tasks: one that produces items
* and other that consumes items.
*
* Note that there is no need for a mutex to guard the @c add_to_buffer() and 
* @c get_from_buffer() functions because of the implicit locking semantics of 
* Co-Routines, so it will never be preempted and will never block except in an 
* explicit #qCR_SemWait statement.
* 
*  @code{.c}
*  #include "HAL.h"
*  #include "QuarkTS.h"
*  #include "AppLibrary.h"
*  
*  #define NUM_ITEMS 32
*  #define BUFSIZE 8
*  
*  qTask_t ProducerTask, ConsumerTask;
*  qCR_Semaphore_t mutex, full, empty;
*  /*===================================================================*/
*  void ProducerTask_Callback( qEvent_t e ) {
*      static int produced;
*      
*      qCR_Begin {
*          for ( produced = 0; produced < NUM_ITEMS; ++produced ) {
*              qCR_SemWait( &full );
*              qCR_SemWait( &mutex );
*      
*              add_to_buffer( produce_item() );
*        
*              qCR_SemSignal( &mutex );
*              qCR_SemSignal( &empty );
*          }
*      } qCR_End;
*  }
*  /*===================================================================*/
*  void ConsumerTask_Callback( qEvent_t e ) {
*      static int consumed;
*      
*      qCR_Begin {
*          for ( consumed = 0; consumed < NUM_ITEMS; ++consumed ) {
*              qCR_SemWait( &empty );
*              qCR_SemWait( &mutex );
*      
*              consume_item( get_from_buffer() );
*              qCR_SemSignal( &mutex );
*              qCR_SemSignal( &full );
*          }
*      } qCR_End;
*  }
*  /*===================================================================*/
*  void IdleTask_Callback( qEvent_t e ) {
*      /*nothing to do*/
*  } 
*  /*===================================================================*/
*  int main(void) {
*      HAL_Init();
*    
*      qOS_Setup( HAL_GetTick, 0.001, IdleTask_Callback );
*      qCR_SemInit( &empty, 0 );
*      qCR_SemInit( &full, BUFSIZE );
*      qCR_SemInit( &mutex, 1 );
*      
*      qOS_Add_Task( &ProducerTask, ProducerTask_Callback,
*                    qMedium_Priority, 0.1, qPeriodic, qEnabled, NULL );
*      qOS_Add_Task( &ConsumerTask, ConsumerTask_Callback,
*                    qMedium_Priority, 0.1, qPeriodic, qEnabled, NULL );
*      qOS_Run();
*      return 0;
*  }
*  @endcode
*
* @subsection q_coroutine_ext External control
* There are several circumstances where becomes necessary to control the flow 
* of execution outside the segment that defines the Co-routine itself. This is 
* usually used to defer the job of the Co-routine or resume it in response to 
* specific occurrences that arises in other contexts, either tasks or interrupts.
*
* To code this specific situations, a handler to the Co-routine should be 
* defined, a variable of type @ref qCR_Handle_t. In addition to this, the scope of 
* the target Co-routine must be started
* with the #qCR_BeginWithHandle statement instead of #qCR_Begin.
* 
*  @code{.c}
*  qCR_Handle_t xHandleCR = NULL; /*NULL initialization are strictly necessary*/
*  
*  /*===================================================================*/
*  void AnotherTask_Callback( qEvent_t e) {
*      int UserInput = 0;
*      if ( e->FirstIteration ) {
*          qCR_ExternControl( xHandleCR, qCR_RESUME, 0 );
*      }
*      if ( e->LastIteration ) {
*          qCR_ExternControl( xHandleCR, qCR_SUSPEND, 0 );
*      }
*      UserInput = GetTerminalInput( );
*      if ( UserInput == USR_RESTART ) {
*          qCR_ExternControl( xHandleCR, qCR_RESTART, 0 );
*      }
*      Perform_AnotherTask_Activities();
*  }
*  /*===================================================================*/
*  void CoroutineTask_Callback( qEvent_t e ) {
*      qCR_BeginWithHandle( xHandleCR ) { /*externally controlled*/
*          if ( EventNotComing() ) {
*              qCR_Yield;
*          }
*          RunFirstJob();
*          qCR_Delay( WAIT_TIME );
*          SecondJobStatus = RunSecondJob();
*          qCR_TimedWaitUntil( JobFlag == JOB_SUCCESS, JOB_TIMEOUT );
*          CleanUpStatus = CleanupJob();
*          qCR_WaitUntil( SomeVar > SomeValue );
*      } qCR_End;
*  }
*  @endcode
*
* As seen in the code snippet above, the Co-routine handle its globally declared
* to allow other contexts to access it. The example shows that another task can 
* control the Coroutine using the qCR_ExternControl() API. The actions performed
* by this API can be only be effective after the handle instantiation, an 
* operation that takes place once on the first call of the Co-routine.
*
* @note A @c NULL initialization its mandatory on @ref qCR_Handle_t variables. 
* Undefined behavior may occur if this step is ignored.
* 
* @section q_atcli AT Command Line Interface (CLI)
* A command-line interface (CLI) is a way to interact directly with the software 
* of an embedded system in the form of text commands and responses. It can be 
* seen as a typed set of commands to produce a result, but here, the commands 
* are typed in real-time by a user through a specific interface, for example, 
* UART, USB, LAN, etc.
*
* A CLI is often developed to aid initial driver development and debugging. This 
* CLI might become the interface (or one of the interfaces) used by a 
* sophisticated end-user to interact with the product. Think of typing commands
* to control a machine, or perhaps for low-level access to the control system as 
* a development tool, tweaking time-constants and monitoring low-level system 
* performance during testing.
* 
* @subsection q_atcli_components The components of the CLI
* The provided development API parses and handles input commands, following a 
* simplified form of the extended AT-commands syntax.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>atcli</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.2,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T19:31:39.234Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;iXCP-aXpe9eB9d0tPXyv\&quot; version=\&quot;20.4.1\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;o9YKW9kYFg2IcPfcP6fb\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>AT CLI implementation</em>
* </center>
* 
* As seen in figure, the CLI has a few components described below:
*
* - <b>Input Handler</b> : It is responsible for collecting incoming data from 
* the input in the form of ASCII characters inside a buffer. When this buffer is
* ready by receiving an EOL(End-Of-Line) byte, it notifies the validator to 
* perform the initial checks.
* - <b>Validator</b> : Take the input string and perform three checks over it:
*   -# The input matches one of the subscribed commands.
*   -# The input matches one of the default commands.
*   -# The input is unknown
* - <b>Pre-Parser</b> : Takes the input if the validator asserts the first check.
* It is responsible for syntax validation and classification. Also, prepares the
* input argument for the next component.
* - <b>Callback or Post-Parser</b> : If input at the pre-parser is valid, the 
* respective command callback is invoked. Here, the application writer is free 
* to handle the command execution and the output response.
* - <b>Output printer</b> : Takes all the return status of the previous 
* components to print out a response at the output.
* 
* @remark Here, @a Input and @a Output should be provided by the application 
* writer, for example, if a UART interface is chosen, the input should take 
* the received bytes from an ISR and the output is a function to print out a 
* single byte.
*
* @subsection q_atcli_syntax Supported syntax
* The syntax is straightforward and the rules are provided below:
*
* - All command lines must start with AT and end with an @c EOL character. By 
* default, the CLI uses the carriage return character. (We will use @c CR to 
* represent a carriage return character in this document).
* - AT commands are case-insensitive
* - Only four types of AT commands are allowed:
*     - Acting (::qATCLI_CMDTYPE_ACT) : This is the simplest type of commands 
*     that can be subscribed. Its normally used to execute the action that the 
*     command should do. This type does not take arguments or modifiers, for 
*     example : @c AT+CMD
*     - Read (::qATCLI_CMDTYPE_READ) : This type of command allows you to read 
*     or test a value already configured for the specified parameter. Only one 
*     argumentis allowed. for example @c "AT+CMD?" or @c "AT+CMD?PARAM1"
*     - Test (::qATCLI_CMDTYPE_TEST) : These types of commands allow you to get
*     the values that can be set for its parameters. No parameters are allowed 
*     here. Example @c "AT+CMD=?"
*     - Parameter Set (::qATCLI_CMDTYPE_PARA) : These types of commands allow 
*     n arguments to be passed for setting parameters, for example: @c AT+CMD=x,y
*  If none of the types is given at the input, the command response will be 
*  @c ERROR
* - The possible output responses are:
*     - @c OK: Indicates the successful execution of the command.
*     - @c ERROR: A generalized message to indicate failure in executing the command.
*     - @c UNKNOWN : The input command its not subscribed.
*     - <tt>NOT ALLOWED</tt> : The command syntax is not one of the allowed types.
*     - User-defined: A custom output message defined by the application writer.
*     - @c NONE : No response.
*
* All responses are followed by a @c CR @c LF
*
* Errors generated during the execution of these AT commands could be due to the
* following reasons:
* - Incorrect syntax/parameters of the AT command
* - Bad parameters or not allowed operations defined by the application writer.
*
* In case of an error, the string @c ERROR or @c "ERROR:<error_no>" are displayed.
*
* @subsection q_atcli_setup Setting up an AT-CLI instance
* Before starting the CLI development, the corresponding instance must be 
* defined; a data structure of type @ref qATCLI_t. The instance should be 
* initialized using the qATCLI_Setup() API.
*
* @subsection q_atcli_sub_commands  Subscribing commands to the parser
* The AT CLI is able to subscribe any number of custom AT commands. For this, the
* qATCLI_CmdSubscribe() API should be used.
*
* This function subscribes the CLI instance to a specific command with an associated
* callback function, so that next time the required command is sent to the CLI input,
* the callback function will be executed. The CLI parser only analyzes commands that
* follow the simplified AT-Commands syntax already described.
*
* @subsection q_atcli_cmd_callback Writting a command callback
* The command callback should be coded by the application writter. Here, the 
* following prototype should be used:
*
*  @code{.c}
*  qATCLI_Response_t CMD_Callback( qATCLI_Handler_t h ) {
*      /* TODO : The command callback */
*  }
*  @endcode
* 
* The callback takes one argument of type @ref qATCLI_Handler_t and returns a 
* single value. The input argument it's just a pointer to public data of the CLI
* instance where the command it subscribed to. From the callback context, can be
* used to print out extra information as a command response, parse the command 
* parameters, and query properties with crucial information about the detected
* command, like the type, the number of arguments, and the subsequent string 
* after the command text. To see more details please check the 
* @ref qATCLI_Handler_t struct reference.
*
* The return value (an enum of type @ref qATCLI_Response_t) determines the 
* response shown by the Output printer component. The possible allowed values are:
*
* - ::qATCLI_OK : as expected, print out the OK string.
* - ::qATCLI_ERROR : as expected, print out the ERROR string.
* - ::qATCLI_ERRORCODE(no) : Used to indicate an error code. This code is 
* defined by the application writer and should be a value between @c 1 and 
* @c 32766. For example, a return value of @c QATCLI_ERRORCODE(15), will print 
* out the string @c ERROR:15.
* - ::qATCLI_NORESPONSE : No response will be printed out.
* 
* A simple example of how the command callback should be coded is showed below:
*
*  @code{.c}
*  qATCLI_Response_t CMD_Callback( qATCLI_Handler_t h ) {
*      qATCLI_Response_t Response = qATCLI_NORESPONSE;
*      int arg1 = 0;
*      float arg2 = 0;
*      /*check the command-type*/
*      switch ( h->Type ) {
*          case qATCLI_CMDTYPE_PARA:
*              if ( h->NumArgs > 0 ) {
*                   arg1 = h->GetArgInt( 1 ); /*get the first argument as integer*/
*                   if ( h->NumArgs > 1 ) {
*                       arg2 = h->GetArgFlt( 2 ); /*get the second argument as float*/
*                   }
*              }
*              sprintf( h->Output, "arg1 = %d arg2 = %f", arg1, arg2 );
*              Response = qATCLI_NORESPONSE;
*              break;
*          case qATCLI_CMDTYPE_TEST:
*              h->puts( "inmediate message" );
*              Response = qATCLI_OK;
*              break;
*          case qATCLI_CMDTYPE_READ:
*              strcpy( h->Output , "Test message after the callback");
*              Response = qATCLI_OK;
*              break;
*          case qATCLI_CMDTYPE_ACT:
*              Response = qATCLI_OK;
*              break;
*          default:
*              Response = qATCLI_ERROR;
*              break;
*      }
*      return Response;
*  }
*  @endcode
*
* @subsection q_atcli_inputh Handling the input
* Input handling is simplified using the provided APIs. The qATCLI_ISRHandler() 
* and qATCLI_ISRHandlerBlock() functions are intended to be used from the 
* interrupt context. This avoids any kind of polling implementation and allows 
* the CLI application to be designed using an event-driven pattern.
*
* Both functions feed the parser input, the first one with a single character 
* and the second with a string. The application writer should call one of these
* functions from the desired hardware interface, for example, from a UART 
* receive ISR.
*
* If there are no intention to feed the input from the ISR context, the APIs 
* qATCLI_Raise() or qATCLI_Exec() can be called at demand from the base context.
* As expected, both functions send the string to the specified CLI. The 
* difference between both APIs is that qATCLI_Raise() sends the command through
* the input, marking it as ready for parsing and acting as the Input handler 
* component. 
*
* The qATCLI_Exec(), on the other hand, executes the components of Pre-parsing 
* and Postparsing bypassing the other components, including the Output printer, 
* so that it must be handled by the application writer.
* 
* @note All functions involved with the component Input-handler, ignores 
* non-graphic characters and cast any uppercase to lowercase.
*
* @subsection q_atcli_run Running the CLI parser
* The parser can be invoked directly using the qATCLI_Run() API. Almost all the 
* components that make up the CLI are performed by this API, except for the 
* Input Handler, that should be managed by the application writer itself.
*
* In this way, the writer of the application must implement the logic that leads
* this function to be called when the input-ready condition is given.
*
* The simple approach for this is to check the return value of any of the input 
* feeder APIs and set a notification variable when they report a ready input. 
* Later in the base context, a polling job should be performed over this 
* notification variable, running the parser when their value is true, then 
* clearing the value after to avoid unnecessary overhead.
*
* The recommended implementation is to leave this job be handled by a task 
* instead of coding the logic to know when the CLI should run. For this, the 
* qOS_Add_ATCLITask() is provided. This API add a task to the scheduling scheme
* running an AT Command Line Interface and treated as an event-triggered task. 
* The address of the parser instance will be stored in the @c TaskData 
* storage-Pointer. 
*
* After invoked, both CLI and task are linked together in such a way that when 
* an input-ready condition is given, a notification event is sent to the task
* launching the CLI components. As the task is event-triggered, there is no 
* additional overhead and the writer of the application can assign a priority 
* value to balance the application against other tasks in the scheduling scheme.
*
* @subsection q_atcli_example1 A CLI example
* The following example demonstrates the usage of a simple command-line interface
* using the UART peripheral with two subscribed commands :
* - A command to write and read the state of a GPIO pin @c "at+gpio".
* - A command to retrieve the compilation timestamp @c "at+info".
* First, lets get started defining the required objects to setup the CLI instance:
*
*  @code{.c}
*  #define CLI_MAX_INPUT_BUFF_SIZE         ( 128 )
*  #define CLI_MAX_OUTPUT_BUFF_SIZE        ( 128 )
*  
*  qTask_t CLI_Task;
*  qATCLI_t CLI_Object;
*  qATCLI_Command_t AT_GPIO, AT_INFO;
*  
*  char CLI_Input[ AT_CLI_MAX_INPUT_BUFF_SIZE ];
*  char CLI_Output[ AT_CLI_MAX_OUTPUT_BUFF_SIZE ];
*  
*  /*Command callbacks*/
*  qATCLI_Response_t AT_GPIO_Callback( qATCLI_Handler_t h );
*  qATCLI_Response_t AT_INFO_Callback( qATCLI_Handler_t h );
*  @endcode
*
* Then the CLI instance its configured by subscribing commands and adding the task
* to the OS. A wrapper function its required here to make the UART output-function
* compatible with the CLI API.
*
*  @code{.c}
*  void CLI_OutputChar_Wrapper( void *sp, const char c ) { /*CLI output function*/
*      (void)sp; /*unused*/
*      HAL_UART_WriteChar( UART1, c );
*  }
*  /*==================================================================*/
*  int main( void ) {
*      HAL_Setup();
*      qOS_Setup( HAL_GetTick, TIMER_TICK, NULL );
*      qATCLI_Setup( &CLI_Object, BSP_UART_PUTC, CLI_Input, sizeof(CLI_Input), 
*                    CLI_Output, sizeof(CLI_Output) );
*      
*      qATCLI_CmdSubscribe( &CLI_Object, &AT_GPIO, "at+gpio", AT_GPIO_Callback, 
*                           QATCLI_CMDTYPE_ACT | QATCLI_CMDTYPE_READ | 
*                           QATCLI_CMDTYPE_TEST | QATCLI_CMDTYPE_PARA | 0x22, NULL );
*      qATCLI_CmdSubscribe( &CLI_Object, &AT_INFO, "at+info", AT_INFO_Callback, 
*                           QATCLI_CMDTYPE_ACT, NULL );
*      qOS_Add_ATCLITask( &CLI_Task, &CLI_Object, qLowest_Priority );
*      qOS_Run();
*  
*      return 0;
*  }
*  @endcode
*
* The CLI input its feeded from the interrupt context by using the UART receive
* ISR:
*
*  @code{.c}
*  void interrupt HAL_UART_RxInterrupt( void ) {
*      char received;
*      
*      received = HAL_HUART_GetChar( UART1 );
*      qATCLI_ISRHandler( &CLI_Object, received ); /*Feed the CLI input*/
*  }
*  @endcode
*
* Finally, the command-callbacks are later defined to perform the requested 
* operations.
*
*  @code{.c}
*  qATCLI_Response_t AT_GPIO_Callback( qATCLI_Handler_t h ) {
*      qATCLI_Response_t RetValue = qATCLI_ERROR;
*      int pin, value;
*     
*      switch ( h->Type ) {
*          case qATCLI_CMDTYPE_ACT: /*< AT+gpio */
*              RetValue = qATCLI_OK;
*              break;
*          case qATCLI_CMDTYPE_TEST: /*< AT+gpio=? */
*              h->puts( "+gpio=<pin>,<value>\r\n" );
*              h->puts( "+gpio?\r\n" );
*              RetValue = qATCLI_NORESPONSE;
*              break;
*          case qATCLI_CMDTYPE_READ: /*< AT+gpio? */
*              sprintf( h->Output, "0x%08X", HAL_GPIO_Read( GPIOA ) );
*              RetValue = qATCLI_NORESPONSE;
*              break;
*          case qATCLI_CMDTYPE_PARA: /*< AT+gpio=<pin>,<value> */
*              pin = h->GetArgInt( 1 );
*              value = h->GetArgInt( 2 );
*              HAL_GPIO_WRITE( GPIOA, pin, value );
*              RetValue = qATCLI_OK;
*              break;
*          default : break;
*      }
*       
*      return RetValue;
*  }
*  /*==================================================================*/
*  qATCLI_Response_t AT_INFO_Callback( qATCLI_Handler_t h ) {
*      qATCLI_Response_t RetValue = qATCLI_ERROR;
*     
*      switch ( param->Type ) {
*          case qATCLI_CMDTYPE_ACT: /*< AT+info */
*              strcpy( h->Output, "Compilation: " __DATE__ " " __TIME__ );
*              RetValue = qATCLI_NORESPONSE;
*              break;
*          default :
*              break;
*      }
* 
*      return RetValue;
*  }
*  @endcode
*
* @section q_memmang Memory Management
* As the OS is targered to build safe-critical embedded applications, dynamic 
* memory allocation its not allowed for the kernel design, because can lead to 
* out-of-storage run-time failures, which are undesirable. However, some 
* applications can be easily deployed using this allocation scheme, so a safe 
* and portable implementation becomes relevant in the scope of the user-code.
*
* In a typical C environment, memory can be allocated using the standard 
* library functions @c malloc() and @c free(), but they may not be suitable in
* most embedded applications because they are not always available on small 
* microcontrollers or their implementation can be relatively large, taking up 
* valuable code space. Also, there is a range of unspecified and 
* implementation-defined behaviour associated with dynamic memory allocation, as
* well as a number of other potential pitfalls. Additionally, some implementations
* can suffer from fragmentation.
*
* To get around this problem, the OS provides its own memory-management 
* interface for dynamic allocation as a fully kernel-independent extension. When 
* the application requires RAM, instead of calling @c malloc(), call qMalloc().
* When RAM is being freed, instead of calling @c free(), use qFree(). Both 
* functions have the same prototype as the standard C library counterparts.
*
* @subsection q_memmang_principle Principle of operation
* The allocation scheme works by subdividing a static array into smaller blocks
* and using the First-Fit approach.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>memmang</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-19T19:51:25.020Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;0et5L84sQ8dq70hh7EnJ\&quot; version=\&quot;20.4.1\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;qnkYvIl8hSz6jSiMQ8AJ\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>First-fit allocation policy</em>
* </center>
* 
*
* If adjacent free blocks are available, the implementation combines them into 
* a single larger block, minimizing the risk of fragmentation, making it 
* suitable for applications that repeatedly allocate and free different sized 
* blocks of RAM.
*
* @note Because memory is statically declared, it will make the application
* appear to consume a lot of RAM, even before any memory has been allocated
* from it.
* 
* @warning All the memory management APIs are NOT interrupt-safe. Use these APIs
* only from the base context.
*
* @attention The application is not exempt from memory leaks if the user does
* not perform adequate memory management. Here, the worst case scenario can
* occur in the absence of free memory.
* 
* @subsection q_memmang_pools Memory pools
* A memory pool its a special resource that allows memory blocks to be dynamically
* allocated from a user-designated memory region. Instead of typical pools with
* fixedsize block allocation, the pools in QuarkTS can be of any size, thereby
* the user is responsible for selecting the appropriate memory pool to allocate 
* data with the same size.
*
* The default memory management unit resides in a memory pool object. Also 
* called the @a "default pool". The total amount of available heap space in the 
* default memory pool is set by @c Q_DEFAULT_HEAP_SIZE, which is defined in 
* @c qconfig.h.
*
* Besides the default pool, any number of additional memory pools can be defined. 
* Like any other object in QuarkTS, memory pools are referenced by handles, a 
* variable of type @ref qMemMang_Pool_t and should be initialized before use 
* with the qMemMang_Pool_Setup() API function.
*
* To perform operations in another memory pool, besides the default pool, an 
* explicit switch should be performed using qMemMang_Pool_Select() . Here, a 
* pointer to the target pool should be passed as input argument. From now on, 
* every call to qMalloc(), or qFree() will run over the newly selected memory 
* pool. To return to the default pool, a new call to qMemMang_Pool_Select() is 
* required passing @c NULL as input argument.
* 
* To keep track of the memory usage, the qMemMang_Get_FreeSize() API function 
* returns the number of free bytes in the memory pool at the time the function 
* is called.
*
* @subsection q_memmang_usage Usage example
*
*  @code{.c}
*  #include <stdio.h>
*  #include <stdlib.h>
*  #include "QuarkTS.h"
*  #include "HAL.h"
*  #include "Core.h"
*  
*  qTask_t taskA;
*  qMemMang_Pool_t another_heap;
*  void taskA_Callback( qEvent_t e );
*  
*  void taskA_Callback( qEvent_t e ) {
*      int *xdata = NULL;
*      int *ydata = NULL;
*      int *xyoper = NULL;
*      int n = 20;
*      int i;
*      
*      xyoper = (int*)qMalloc( n*sizeof(int) );
*      xdata = (int*)qMalloc( n*sizeof(int) );
*      qMemMang_Pool_Select( &another_heap ); /*change the memory pool*/
*      /*ydata will point to a segment allocated in another pool*/
*      ydata = (int*)qMalloc( n*sizeof(int) ); 
*      
*      /*use the memory if could be allocated*/
*      if ( xdata && ydata && xyoper ) {
*          for ( i = 0 ; i < n ; i++ ) {
*              xdata[ i ] = GetXData();
*              ydata[ i ] = GetYData();
*              xyoper[ i ] = xdata[ i ]*ydata[ i ];
*          }
*          UseTheMemmory(xyoper);
*      }
*      else {
*          qTrace_Message("ERROR:ALLOCATION_FAIL");
*      }
*  
*      qFree( ydata );
*      qMemMang_Pool_Select( NULL ); /*return to the default pool*/
*      qFree( xdata );
*      qFree( xyoper );
*  }
*  
*  int main(void) {
*      char area_another_heap[ 512 ] = { 0 };
*      qTrace_Set_OutputFcn( OutPutChar );
*      /*Create a memory heap*/
*      qMemMang_Pool_Setup( &another_heap, area_another_heap, 512);
*      qOS_Setup( HAL_GetTick, 0.001f, IdleTaskCallback );
*      qOS_Add_Task( &taskA, taskA_Callback, qLowest_Priority, 0.1f, qPeriodic, qEnabled, NULL );
*      qOS_Run();
*      return 0;
*  }
*  @endcode
*
* @section q_trace Trace and debugging
* QuarkTS include some basic macros to print out debugging messages. Messages 
* can be simple text or the value of variables in specific base-formats. 
* To use the trace macros, a single-char output function must be defined using
* the qTrace_Set_OutputFcn() macro.
*
* A single-char output function should follow this prototype:
*
*  @code{.c}
*  void SingleChar_OutputFcn ( void *sp , const char c ) {
*      /* TODO : print out the c variable using the
*       * selected peripheral.
*       */
*  }
*  @endcode
*
* The body of this user-defined function should have a hardware-dependent code 
* to print out the @c c variable through a specific peripheral.
*
* @subsection q_trace_viewvars Viewing variables
* For viewing or tracing a variable (up to 32-bit data) through debug, one of 
* the following macros are available: #qTrace_Var or #qDebug_Var.
*
* The only difference between qTrace_ and Debug, is that @c qTrace_ macros, 
* print out additional information provided by the @c __FILE__ , @c __LINE__ and
* @c __func__ built-in preprocessing macros, mostly available in common C 
* compilers.
*
* @subsection q_trace_mblock Viewing a memory block
* For tracing memory from a specified target address, one of the following
* macros are available: #qTrace_Mem or  #qDebug_Mem.
*
* @subsection q_trace_usage Usage
* In the example below, an UART output function is coded to act as the printer.
* Here, the target MCU is an ARM-Cortex M0 with the UART1 as the selected 
* peripheral for this purpose.
*
*  @code{.c}
*  void putUART1 ( void *sp , const char c ) {
*      /* hardware specific code */
*      UART1_D = c;
*      while ( !( UART1_S1 & UART_S1_TC_MASK ) ) {} /*wait until TX is done*/
*  }
*  @endcode
*
* As seen above, the function follows the required prototype. Later, in the 
* main thread, call to qTrace_Set_OutputFcn() is used to set up the output-function.
*
*  @code{.c}
*  int main( void ) {
*      qTrace_Set_OutputFcn( putUART1 );
*      ...
*      ...
*  }
*  @endcode
*
* After that, trace macros will be available for use.
*
*  @code{.c}
*  void IO_TASK_Callback ( qEvent_t e ) {
*      static qUINT32_t Counter = 0;
*      float Sample;
*      ...
*      ...
*      qTrace_Message( "IO TASK running..." );
*      Counter++;
*      qTrace_Variable( Counter , UnsignedDecimal );
*      Sample = SensorGetSample ();
*      qTrace_Variable( Sample , Float );
*      ...
*      ...
*  }
*  @endcode
*/