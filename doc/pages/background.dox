/*! @page q_background Background
* @tableofcontents
*
* @section q_about About the OS
* QuarkTS is an open-source operating system that is built on top of a 
* <em>cooperative quasistatic scheduler</em>. Its simplified kernel implements a 
* specialized round-robin scheme using a linked-chain approach and an 
* event-queue to provide true FIFO priority scheduling.
* 
* <b> @b Why cooperative? </b>
*
* Rather than having preemption, tasks manage their own life-cycle. This bring 
* significant benefits, fewer re-entrance problems are encountered, because 
* tasks cannot be interrupted arbitrarily by other tasks, but only at positions
* permitted by the programmer, so you mostly do not need to worry about pitfalls 
* of the concurrent approach(resource sharing, races, deadlocks, etc...).
*
* <b> What is it made for? </b>

* The design goal of QuarkTS is to achieve its stated functionality using a 
* small, simple, and (most importantly) robust implementation to make it 
* suitable on resource constrained microcontrollers, where a full-preemptive RTOS
* is an overkill and their inclusion adds unnecessary complexity to the firmware 
* development. In addition with a @ref q_fsm support, @ref q_qcoroutines, time 
* control and the inter-task communication primitives, QuarkTS provides a modern
* environment to build stable and predictable event-driven multitasking embedded
* software. Their modularity and reliability make this OS a great choice to 
* develop efficiently a wide range of applications in low-cost devices, 
* including automotive controls, monitoring and Internet of Things
*
* <b>Why should I choose it?</b>
*
* QuarkTS is not intended to replace o compete with the other great and proven
* RTOS options already available today, for example FreeRTOS or MicroC/OS-II,
* in fact, you should check these options first. However, due to its size and
* features, is intended to play in the space between RTOSes and bare-metal.
* QuarkTS was written for embedded developers who want more functionality than
* what existing task schedulers offer, but want to avoid the space and
* complexity of a full RTOS, but keeping the taste of a robust and safe one.
*
* @subsection q_license License
* QuarkTS is licensed under the MIT License. You may copy, distribute and modify
* the software without any restriction, including without limitation the rights 
* to to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
* copies of the OS, and to permit persons to whom the OS is furnished to do so. 
* This OS is provided as is in the hope that it will be useful, but WITHOUT ANY 
* WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR 
* A PARTICULAR PURPOSE . 
*
* For more details, see the <a style="font-weight:bold" href="https://writing.kemitchell.com/2016/09/21/MIT-License-Line-by-Line.html">MIT License</a> line by line.
* 
*
* @subsection q_hardwarecompatibility Hardware compatibility
* QuarkTS has no direct hardware dependencies, so it is portable to many 
* platforms and C compilers. 
* 
* The following cores have been powered with QuarkTS successfully:
*
* - ARM cores(ATMEL, STM32, LPC, Kinetis, Nordic and others)
* - 8Bit AVR, 8051, STM8
* - HCS12, ColdFire, MSP430
* - PIC (PIC24, dsPIC, 32MX, 32MZ)
*
* @subsection q_codstandard Development process and coding starndard
* QuarkTS is developed using a formal and rigorous process framed in compliance
* of the <a style="font-weight:bold" href="https://www.misra.org.uk/">MISRA C 2012</a>
* and <a style="font-weight:bold" href="https://wiki.sei.cmu.edu/confluence/display/c/SEI+CERT+C+Coding+Standard">SEI CERT coding standard</a>
* guidelines and complemented with multiple static-analysis checks targered to
* safe critical applications.
*
* Simply using QuarkTS in an application, does not mean developers can make a 
* claim related to the development process and compliance of the OS to any 
* requirements or product specification, without first, following a recognized 
* system wide conformance verification process. Conformance evidence must then 
* be presented, audited and accepted by a recognized and relevant independent 
* assessment organization. Without undergoing this process of due diligence, no
* claim can be made as to the suitability of QuarkTS to be used in any safety or
* otherwise commercially critical application.
*
* Besides the previous information, the OS sets the following clarifications 
* regarding coding policies and naming convention:
*
* - All the QuarkTS implementation follows the <b>ANSI C99</b> standard strictly.
* - Dynamic memory allocation is banned to conform the industry standards for
* safety-critical software: @b MISRA-C, @b DO178B, @b IEC-61508, @b ISO-26262 
* and so on.
* - Because errors in string manipulation have long been recognized as a leading
* source of buffer overflows in C, a number of mitigation strategies have been
* devised. These include mitigation strategies designed to prevent buffer 
* overflows from occurring and strategies designed to detect buffer overflows 
* and securely recover without allowing the failure to be exploited.
* - In line with MISRA guides and for portability between platforms, we use the
* @c stdint.h with typedefs that indicate size and signedness in place of the basic
* types.
* - In line with @b MISRA guides, unqualified standard @c char and @c char* types 
* are only permitted to hold ASCII characters and strings respectively.
* - The @c _t suffix its used to denote a type definition (i.e @c qBool_t , 
* @c qTask_t , @c size_t, ...).
* - Functions, macros, enum values and data-types are prefixed q. (i.e. 
* @c qFunction, @c qEnumValue, @c QCONSTANT, @c qType_t, ...)
* - Other than the pre-fix, most macros used for constants are written in all 
* upper case.
* - Almost all functions returns a boolean value of type @c qBool_t, where a
* @c qTrue - @c 1u
* value indicates a successful procedure and @c qFalse - @c 0u, the failure of 
* the procedure
* 
* @subsection q_memusage Memory usage
* As a quasi-static scheduler is implemented here, dynamic scheduling is not 
* required and the assignment of tasks must be done before program execution 
* begins. The kernel is designed to allow unlimited tasks and kernel objects, 
* but of course, the whole application will be constrained by the memory 
* specifications of the embedded system.
*
* The kernel's memory footprint can be scaled down to contain only the features 
* required for your application, typically 3.7 KBytes of code space and less 
* than 1 KByte of data space.
*
* <center>
* <table>
* <caption id="multi_row">OS Memory footprint (Measured in a 32-bit MCU)</caption>
* <tr><th>Functionality  <th>Size(bytes)
* <tr><td> Kernel, scheduler and task management <td>2637
* <tr><td> A task node @c qTask_t <td>68
* <tr><td> Finite State machines(FSM) handling and related APIs <td>314
* <tr><td> A FSM object @c qSM_t <td> 100
* <tr><td> A state object @c qSM_State_t <td> 36
* <tr><td> STimers handling and related APIs <td> 258
* <tr><td> A STimer object @c qSTimer_t <td> 8
* <tr><td> Queues handling and related APIs <td> 544
* <tr><td> A queue object @c qQueue_t <td> 28
* <tr><td> Memory management <td> 407
* <tr><td> A memory pool <td> 28
* <tr><td> The AT Command Line Interface <td> 1724
* <tr><td> An AT-CLI instance @c qATCLI_t <td> 112
* <tr><td> An AT-CLI command instance @c qATCLI_Command_t <td> 24
* <tr><td> Remaining utilities <td> 2980
* </table>
* </center>
* 
* @note Although the kernel does not use dynamically-allocated resources 
* internally, the application writer can create an object in run-time using the
* safe-heap implementation provided by the @ref q_memmang extension. Of course, 
* additional checks must be performed to keep the solution safe.
*
* @section q_getos Getting the OS
* Download the latest release from the official repository :
*
* <a style="font-weight:bold" href="https://github.com/kmilo17pet/QuarkTS/releases">QuarkTS Releases</a>
* 
* Unpack the release package and add the sources files to your project.
*
* @subsection q_cloneos Cloning QuarkTS
* You only need to clone the @c kernel branch as follows:
*
* @code{.sh}
* git clone -b kernel https://github.com/kmilo17pet/QuarkTS.git
* @endcode
*
* @subsection q_submodule Including QuarkTS as a git sub-module
* Add the OS kernel as a submodule to your project:
*
* @code{.sh}
* git submodule add -b kernel https://github.com/kmilo17pet/QuarkTS.git <destination path>
* @endcode
*
* Then, run the initialize command to fetch the code for the first time:
*
* @code{.sh}
* git submodule update --init
* @endcode
*
* To update the submodule to the latest just run:
*
* @code{.sh}
* git submodule update --remote
* @endcode
*
* @subsection q_getqconfig Get a copy of the OS configuration file
* The file @c qconfig.h provides specific @ref q_configmacros to customize 
* several aspects of OS. In order to build your solution with QuarkTS, you should
* provided your own copy of this configuration file. You can obtain a copy
* with the default configuration by issuing the following command:
*
* @code{.sh}
* curl https://raw.githubusercontent.com/kmilo17pet/QuarkTS/master/src/config/qconfig.h -o <destination path>/qconfig.h
* @endcode
*
* @section q_timmingapproach Timming Approach
* The kernel implements a <a style="font-weight:bold" href="https://en.wikipedia.org/wiki/Time-triggered_architecture">Time-Triggered Architecture (TTA)</a>
* , in which the tasks are triggered by comparing the corresponding task-time 
* with a reference clock. The reference clock must be real-time and follow a
* monotonic behavior. Usually, all embedded systems can provide this kind of 
* reference with a constant tick generated by a periodic background 
* hardware-timer, typically, at @c 1Khz or @c 1mS tick.
*
* For this, the kernel allows you to select the reference clock source among 
* these two scenarios:
*
* - <b>When tick already provided</b>: The reference is supplied by the Hardware 
* Abstraction Layer (HAL) of the device. It is the simplest scenario and it 
* occurs when the framework or SDK of the embedded system includes a HAL-API 
* that obtains the time elapsed since the system starts, usually in milliseconds
* and taking a 32-bit counter variable.
* - <b>When the tick is not provided</b>: The application writer should use bare-metal 
* code to configure the device and feed the reference clock manually. Here, a 
* hardware timer should raise an interrupt periodically. After the <em>Interrupt 
* Service Routine(ISR)</em> has been implemented using the platform-dependent code, 
* the qClock_SysTick() API must be called inside. It is recommended that the 
* reserved ISR should only be used by QuarkTS.
* 
* @section q_setupkernel Setting up the OS kernel
* The qOS_Setup() function should be the first call to the OS APIs. qOS_Setup() 
* prepares the kernel instance, sets the reference clock, defines the Idle-Task 
* callback and allocates the stack for the internal queue.
*
* @note This call is mandatory and must be called once in the application main 
* thread before any kind of interaction with the OS.
*
* Usage example:
* - Scenario 1 : When tick is already provided
*  @code{.c}
*  #include "QuarkTS.h"
*  #include "HAL.h"
*
*  #define TIMER_TICK 0.001 /* 1ms */
*
*  void main( void ) {
*      HAL_Init();
*      qOS_Setup( HAL_GetTick , TIMER_TICK , IdleTask_Callback );
*      // TODO: add Tasks to the scheduler scheme and run the OS
*  }
*  @endcode
*
* - Scenario 2 : When the tick is not provided
*  @code{.c}
*  #include "QuarkTS.h"
*  #include "DeviceHeader.h"
*
*  #define TIMER_TICK       ( 0.001f ) /* 1ms */
*
*  void Interrupt_Timer0( void ) {
*      qClock_SysTick();
*  }
* 
*  void main( void ) {
       MCU_Init();
*      HAL_Init();
*      qOS_Setup( NULL , TIMER_TICK , IdleTask_Callback );
*      // TODO: add Tasks to the scheduler scheme and run the OS
*  }
*  @endcode
*
* @section q_tasks Tasks
* Like many operating systems, the basic unit of work is the task. Tasks can 
* perform certain functions, which could require periodic or one-time execution,
* update of specific variables or waiting for specific events. Tasks also could
* be controlling specific hardware or be triggered by hardware interrupts. In 
* the QuarkTS OS, a task is seen as a node concept that links together:
*
* - Program code performing specific task activities (callback function)
* - Execution interval (time)
* - Number of execution (iterations)
* - Event-based data
*
* The OS uses a <b>Task Control Block (TCB)</b> to represent each task, storing 
* essential information about task management and execution. Part of this 
* information also includes link-pointers that allows it to be part of one of 
* the lists available in the <b>Kernel Control Block (KCB)</b>.
* 
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>tasknode</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:11:02.654Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;QycpXy9CV1RyLdRAMmhi\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;Wp6tzC3tOU-Ykbh8yUCR\&quot; name=\&quot;Página-1\&quot;&gt;7VtRb5s6FP41eZm0CHBoyGOTNrfSuulqne62Rw/c4NXBEThNcn/9tcEOYENC2gTQbtpKxQfbsc/3HfvwmQzAbLn9K4ar8DMNEBk4VrAdgLuB49jAdvk/YdlJi+14mWUR40DacsMT/hdJoyWtaxygpFSRUUoYXpWNPo0i5LOSDcYx3ZSrPVNS/tQVXCDD8ORDYlq/44CFaho3k/zGA8KLUH6054yzG0uoKsuZJCEM6KZgAvcDMIspZdnVcjtDRHhP+SVrN6+5ux9YjCLWpMEo+riZh8t/vpCnr3SC0G/iPXyUvbxCspYTloNlO+WBmK6jAIlOrAGYbkLM0NMK+uLuhoPObSFbEl6y+eUzJmRGCY3TtsCyxvP5XNhpxAr27IfbExbTF1TZgvf0JEcRQuaHspc5XGIi2PSAyCti2If7bhRA3LVTOS8UM7StdZi9h4ETGNElYvGOV1ENJhI5xV0HZOVNkQiyTljggEIcSu4t9l3n8PALidAJaDkGWhGPOG4hOHpJ3ofcYSSUPaIRMuH0LPEr7Qo0u3vARl0DBgzA+MpCfkH/5QqWDtZN12CNDLBwxFDMy1ewdLC8rsFyTbA4VpBhGl0XQh0ux+oarhsDLspCFItsDiYvIkGEDA6Hwyt0OnSdJx3ja4pYixYAx1NEr02wvDODdXJEdej7imyvyve2dSnnT66RUouW17NAUUtoARsU8Cd/WaQxC+mCRpDc59ZpGb28ziOlK4nZb8TYTsoYcM1oGVG0xexH4fqn7Epc322LhZ0qRHy2P4qFn8VC3igtqVYHmFCHur+OX9Op2QcoIFx0mADco3Qd++iQ65WOA+MFYgcqOtWMihHhed5reSDnJ8i5pZEeL6V6cHa+ktqm0mGGaxTcCoGPl3wCkwT7ZX+XwblGXq4fHQ08r5otBTq4FXRQtsbxKT/hb8qfswv7+kjLgMeg3EU2TdmqKHjqHdk1tFYdZX4wOkoZu5/2O0hsqj/vJbGipF2i5NBxj7BSsd8qsl82qw2A7qjcFfVqNalTqWffHOno0tQztazLUK/Hq+HRVQ50usrpTy9vpRrQqea2TDVTiXtfnlSRDb2BRm3kSeOun2FMVW37iBPWsv/7J6JpOLld49RAQjtPItA0D2ieBfc6n500XOmzQOlqqXfGZTpO3rrSO+V+GqaznFZwV6i2EhWSE5IgmcfWDcuxKlfFPGCyAZx302mgc176+bDXkdFtGq0R3gZnSqMbZtGnMt6ZVAZoLeFHHRC+gbZcILzctw/sH8EcixH8idwfd8n9kZZ7OP2mPjiR+l7lqC5KfbXrXdf6Pqp1Iy0p2b8ZcirhR67WUctqndNA738bzawz0Gz/8qjVwVFNZxqJllkCnRKNudUxtZxWqDU8LOfWnGccF4+1Y+jARV4w6iVbpR5y9Hlw8iey+lIpgntoyz8aalYbGYJ50LL9lr5WpgUZQ1tmEFeduJqyFyR4EfEiQc+imZCk+N5ObqV5iYMgfS0gWUEfR4vHtNrdKLd8leQRJsqbP5M0KkLeEPEeptL1fGzulP9x181EFLt8rDNetvMy/xPVYzajER8+xGlsIJiwDUpYuj4wyOCvdKZWMQSV+lan0lUmL+XV5iIanaMnDiosjqh0Sjc//8v15pnJh0+z6QDccuMnFEeIDGbO4JZ/vsVR4D4RXU4JFS9z85VHHDeC6YdvqknGQLPqlZN31gFOlqnXrm6sP94AUzjeq13tcPL/e7hS4ftWRXvHPFwRq8E1fPu7pdiWvqVcakfhxfyLe1kak3//Edz/Bw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Task node illustration</em>
* </center>
*
* Each task performs its activities via a @a callback function and each of them is 
* responsible for supporting cooperative multitasking by being “good neighbors”,
* i.e., running their callback methods quickly in a non-blocking way and 
* releasing control back to the scheduler as soon as possible (returning).
*
* Every task node, must be defined using the qTask_t data-type and the callback
* is defined as a function that returns void and takes a qEvent_t data structure
* as its only parameter (This input argument can be used later to get event 
* information, see @ref eventdata).
*
*  @code{.c}
*  qTask_t UserTask;
*  void UserTask_Callback( qEvent_t eventdata ) {
*      // TODO : Task code
*  }
*  @endcode
*
* @note All tasks in QuarkTS must ensure their completion to return the CPU
* control back to the scheduler, otherwise, the scheduler will hold the 
* execution state for that task, preventing the activation of other tasks.
*
* @subsection q_idletask The idle task
* Its a special task loaded by the OS scheduler when there is nothing else to 
* do (no task in the whole scheme has reached the ready state). The idle task is
* already hard-coded into the kernel, ensuring that at least, one task is able 
* to run. Additionally, the OS setup this task with the lowest possible priority
* to ensure that does not use any CPU time if there are higher priority 
* application tasks able to run. The idle task doesn't perform any active 
* functions, but the user can decide if it should perform some activities 
* defining a callback function for it. This could be done at the beginning of 
* the kernel setup. Of course, the callback must follow the same function 
* prototype for tasks.
* @note To disable the idle-task activities, a @c NULL should be passed as 
* argument on qOS_Setup().
*
* @subsection q_addtasks Adding tasks to the scheme
* After setting up the kernel with qOS_Setup(), the user can proceed to deploy 
* the multitasking application by adding tasks. If the task node and their 
* respective callback is already defined, the task can be added to the scheme 
* using qOS_Add_Task(). This API can schedule a task to run every @c t seconds,
* @c n executions times and invoking the @c callbackFcn method on every pass.
*
* <b> Caveats: </b>
*
* -# A task with time argument @c t defined as @c qTimeImmediate, will always 
* get the @c qReady state in every scheduling cycle, as consequence, the idle 
* task will never gets dispatched.
* -# Tasks do not remember the number of iteration set initially by the 
* @c n executions argument. After the iterations are done, the internal iteration
* counter decreases until reach the zero. If another set of iterations is 
* needed, the user should set the number of iterations again and resume the 
* task explicitly.
* -# Tasks that performed all their iterations, put their own state to @c 
* qDisabled. Asynchronous triggers do not affect the iteration counter.
* -# The @c arg parameter can be used as storage pointer, so, for multiple data, 
* create a structure with the required members and pass a pointer to that
* structure.
*
* Invoking qOS_Add_Task() is the most generic way to adding tasks to the scheme, 
* supporting a mixture of time-triggered and event-triggered tasks, however, 
* additional simplified API functions are also provided to add specific purpose
* tasks:
*
* - Event-triggered only tasks → qOS_Add_EventTask().
* - State-machine tasks → qOS_Add_StateMachineTask().
* - AT Command Line Interface tasks → qOS_Add_ATCLITask().
*
* @subsection q_eventtasks Event-triggered tasks
* An event-triggered task reacts asynchronously to the occurrence of events in 
* the system, such as external interrupts or changes in the available resources.
*
* The API qOS_Add_EventTask() is intended to add this kind of tasks, keeping it
* in a @c qSuspended state. Only asynchronous events followed by their priority
* value dictates when a task can change to the @c qRunning state.
* 
* @subsection q_removetask Removing a task
* The qOS_Remove_Task() function removes the task from the scheduling scheme.
* This means the task node will be disconnected from the kernel chain, 
* preventing additional overhead provided by the scheduler when it does checks 
* over it and course, preventing from running.
*
* <b> Caveats: </b>
*
* Task nodes are variables like any other. They allow your application code to 
* reference a task, but there is no link back the other way and the kernel 
* doesn't know anything about the variables, where the variable is allocated 
* (stack, global, static, etc.) or how many copies of the variable you have 
* made, or even if the variable still exists. So the qOS_Remove_Task() API 
* cannot automatically free the resources allocated by the variable. If the task
* node has been dynamically allocated, the application writer it's responsible
* to free the memory block after a removal call.
* 
* @section q_runos Running the OS
* After preparing the multitasking environment for your application, a call to 
* qOS_Run() is required to execute the scheduling scheme. This function is 
* responsible to run the following OS main components:
*
* - <b>The Scheduler</b> : Select the tasks to be submitted into the system and decide 
* with of them are able to run.
* - <b>The Dispatcher</b> : When the scheduler completes its job of selecting ready 
* tasks, it is the dispatcher which takes that task to the running state. This 
* procedure gives a task control over the CPU after it has been selected by the
* scheduler. This involves the following:
*    -# Preparing the resources before the task execution
*    -# Execute the task activities (via the callback function)
*    -# Releasing the resources after the task execution
* 
* The states involved in the interaction between the scheduler and dispatcher 
* are described @ref q_globalstates "here".
* 
* @note  After calling qOS_Run(), the OS scheduler will now be running, and the
* following line should never be reached, however, the user can optionally 
* release it explicitly with qOS_Scheduler_Release() API function.
*
* @subsection q_releasescheduler Releasing the scheduler
* This functionality must be enabled from the @c Q_ALLOW_SCHEDULER_RELEASE 
* macro. This API stop the kernel scheduling. In consequence, the main thread 
* will continue after the qOS_Run() call.
*
* Although producing this action is not a typical desired behavior in any 
* application, it can be used to handle a critical exception.
*
* When used, the release will take place after the current scheduling cycle 
* finish. The kernel can optionally include a release callback function that can
* be configured to get called if the scheduler is released. Defining the release
* callback, will help to take actions over the exception that caused the release
* action. To perform a release action, the qOS_Set_SchedulerReleaseCallback()
* API should be used
*
* @note When a scheduler release is performed, resources are not freed. After
* released, the application can invoke the qOS_Run() again to resume the
* scheduling activities
*
* @section q_globalstates Global states and scheduling rules
* A task can be in one of the four global states: @c qRunning, @c qReady, 
* @c qSuspended or @c qWaiting.
* Each of these states is tracked implicitly by putting the task in one of the 
* associated kernel lists.
*
* These global states are described below:
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>globalstates</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:19:49.977Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;oSuMqHCIxHJLwsXvollB\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;yUrP7yZJVmdYKEqsLdOd\&quot; name=\&quot;Página-1\&quot;&gt;7Vtdb+MoFP01eWxljJ3Yj5O03VlpVqqa3Z2ZfRlRm8ZosEkx+dpfv2DjT5wmzThJs0pbqeYaMNx7OFyOkwGcxOvfOJpHf7AQ04FthesBvBvYNoDAlf+UZaMtwPZyy4yTUNsqw5T8i7XR0tYFCXHaqCgYo4LMm8aAJQkORMOGOGerZrUXRptPnaMZNgzTAFHT+pWEIiqmMfSrG58xmUX60Z49ym/EqKisZ5JGKGSrmgneD+CEMybyq3g9wVR5r/BL3u5hy91yYBwnYp8Gzp//IHbz+9pBkx+vfz/N/uI38Y3uZYnoQk94YA+p7G/8LC9m6qIwvDD5HOVoynhWdfi6YHkF6Fnqt27K274+LZKEJLOiDzm6vJtm19Jce1zmLLEpIsDZIgmxmoQlb68iIvB0jgJ1dyVBJ22RiKksAXmZCs5+4kk5RmhZo4eHBzV8QmlhT1iC9YweUEyoAudnTJdYkACVvRTxtstRLTEXeL3V/6CMqlwPmMVY8I2sUjSwNBD0UoA2zMurCle+rhLVEAW1DWkkz8qeq2DLCx3vd8Te7oh9r773s59f9n2I0igbA+gnEF4zDg6wjThA2BEI4IIjRQIakbgj6RyJIMLciImcuDC8XXjVdDSiZJbIIsUvqpnynHQ0/aTNMQlD1fNYPi+QK/VLVu3OqSxP2gPKxGTzF5qxWCQbYtnDeM5IIjKPuGP5Jx03sW7dgSvHOpFlUJXln6rOxYQlcviIZPHCKBUrnKrBcSaQQM/ZTBXgSsoEGjE1cGnKeQNJTfCauFINp9qvoA9cOQ1c2Z65vr1Trm9n9/rGSfhJbZKyFFCUpiRoLukuF3aRaxkoVS1Y8GW5Xk234zUR33RVdf29dn23rheUI21Xlx4xJ9IvmJeDQVwUg9dYz+eHQ2NLb4VQ+oAteIDf2hi3xLoWTLcjmIWNY4oEWTbH0RVh/YRHtYgqKJWgKPYK6DW7yMevW9U3/VZHwN/RkfTiDAujowxw5bQPx6C7G4MFI31Bz5g+spQIwhQzPTMhWNxBWYK1N54IzVVn8XqmstDbZySBfEvRBnMc/uBZWjjOclKgkMMWgpJE4rjIGC0D6Rk15LkoGL6NfJNWahwsa04m925WsweGsUd+M5rApJgyzajDcngsjhka8X19wijcXHetS9m1bH+4My096bY1ulJGj5Thu81kd3RuxvBMxpgu0jnOXHlljQthjfZh1vHMQ5Q3OiFr+FfW6DPR8ECLNszwnpY2Cj2wzhtfkQyhEpeurHEZrGH78GOxBujSP39FA2uv520hec86p4qvxij4OcuGUmsEoe+X4mYRqJRRNec2PZQP6COO7eNp5znEjKN7tDjuoWXWtA698C9D6Bj0J2roXDA/8+9cFmcTP9qn3EsVP4Cp6/7v2SXboPK86sa3+qEbaLeykQ7F/rR007u0upMrHLdOFv2SVJtxZFj45lu9kA3n1i2KFXtlpWJEPTKVvy9TwfMyVQOX5Uvh9xJVyRTbOjo2Ue0h0x6GZ1DH86072Lb79QfoHkF4XnBBuynMOdaB6Gp3BEfuadFlisR9sWWJqO81rF0KuvakuNFZQQhbIAQHghA4LSESwtOC0JSV000qcDxQH5uRk4SZZIOWiNDsfN2TqBBIXKiN9SordMsKZVmntT19xgO0dO+zv4wHpu6NlzhbITX4BSwJc1mysr0sqMJXf+r4FZJngSR02qeY4V6QdNxjQdLUzBOmABljLGoAFJFkQ6sGzSsMLxiGwG+qKw4cnReGtqns95Ue7iW8ATvLIo93nO4xZ9z3WOx9qJzRsQ88uLQ6gt5+BxcJFbSpVdN0sP0Y77ReZuqX5BWq8x57TUgLv364j+d1iz9vSD9wVClDh2N/J6b9c2K6LSW7oHV8+eiYdu1TYNo2MD0NIhwu6PVzzJfzlrZ8TVJAB5757GT3/R7lQr+p0HWI7f6mAniD4LaEQhar7yLlhFB9pQve/wc=&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Task global states</em>
* </center>
*
* - @c qWaiting : The task cannot run because the conditions for running are 
* not in place.
* - @c qReady : The task has completed preparations for running, but cannot run 
* because a task with a higher precedence is running.
* - @c qRunning : The task is currently being executed.
* - @c qSuspended : The task doesn't take part in what is going on. Normally 
* this state is taken after the @c qRunning state or when the task does not 
* reach the @c qReady state.
*
* The presence of a task in a particular list indicates the task's state. There
* are many ready-lists as defined in the @c Q_PRIORITY_LEVELS macro. To select 
* the target ready list, the OS use the user-assigned priority between 0 (the 
* lowest priority) and @c Q_PRIORITY_LEVELS-1 (the highest priority). For 
* instance, if @c Q_PRIORITY_LEVELS is set to 5, then QuarkTS will use 5 
* priority levels or ready lists: 0 (lowest priority), 1, 2, 3, and 4 (highest 
* priority).
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>oslist</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:21:59.751Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;qu1SGjoOBtXo91H1rG-O\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;a3gmjD7FvNUACDKGX7UC\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>OS lists</em>
* </center>
*
* Except for the idle task, a task exists in one of these states. As the 
* real-time embedded system runs, each task moves from one state to another 
* (moving it from a list to another), according to the logic of a simple finite
* state machine (FSM). The figure above illustrates the typical flowchart used 
* by QuarkTS to handle the task's states, with brief descriptions of state 
* transitions, additionally you may also notice the interaction between the 
* scheduler and the dispatcher.
*
* The OS assumes that none of the tasks does a block anywhere during the 
* @c qRunning state. Based on the round-robin fashion, each ready task runs in 
* turn from every ready lists. The developer should take care to monitor their 
* system execution times to make sure during the worst case, when all tasks have
* to execute, all of the deadlines are still met.
*
* @subsection q_osrules Rules
*
* Task precedence is used as the task scheduling rule and precedence among tasks
* is determined based on the priority of each task. If there are multiple tasks 
* able to run, the one with the highest precedence goes to @c qRunning state 
* first.
*
* In determining precedence among tasks, of those tasks having different 
* priority levels, that with the highest priority has the highest precedence. 
* Among tasks having the same priority, the one that entered the scheduling 
* scheme first has the highest precedence if the @c Q_PRESERVE_TASK_ENTRY_ORDER
* configuration is enabled, otherwise the OS will reserves for himself the order
* according to the dynamics of the kernel lists.
*
* @subsubsection q_os_evenprecedence Event precedence
* The scheduler also has an order of precedence for incoming events, in this 
* way, if events of different nature converge to a single task, these will be 
* served according to the following flowchart:
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>evenprecedence</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:100%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.45,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:23:50.297Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;-HzyQrBmOm1BBi3Kbblc\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;rtI5oX9UaKnuX4kORaYA\&quot; name=\&quot;Página-1\&quot;&gt;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&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Event precedence</em>
* </center>
*
* @subsubsection q_os_operational_states Additional operational states
* Each task has independent operating states from those globally controlled by 
* the scheduler. These states can be handled by the application writer to modify
* the event-flow to the task and consequently, affecting the transition to the 
* @c qReady global state. These states are described as follows:
*
* - @c qAwake : In this state, the task is conceptually in an alert mode, handling
* most of the available events. This operational state is available when the 
* @c SHUTDOWN bit is set, allowing the next operational states to be available:
*    - @c qEnabled : The task is able to catch all the events. This operational 
* state is available when the @c ENABLE bit is set.
*    - @c qDisabled : In this state the time events will be discarded. This 
* operational state is available when the @c ENABLE bit is cleared.
* - @c qAsleep : Task operability is put into a deep doze mode, so the task 
* can not be triggered by the lower precedence events. This operational state 
* is available when the @c SHUTDOWN bit is cleared. The task can exit from this
* operational state when it receives a high precedence event (a queued 
* notification) or using the qTask_Set_State() API.
* 
* The figure bellow shows a better representation of how the event flow can be 
* affected by this operational states.
*
* <center>
* @htmlonly
* <!DOCTYPE html>
* <html>
* <head>
* <title>operationalstates</title>
* <meta charset="utf-8"/>
* </head>
* <body><div class="mxgraph" style="max-width:150%;border:1px solid transparent;" data-mxgraph="{&quot;highlight&quot;:&quot;#0000ff&quot;,&quot;nav&quot;:true,&quot;zoom&quot;:1.45,&quot;resize&quot;:true,&quot;toolbar&quot;:&quot;zoom layers tags lightbox&quot;,&quot;edit&quot;:&quot;_blank&quot;,&quot;xml&quot;:&quot;&lt;mxfile host=\&quot;app.diagrams.net\&quot; modified=\&quot;2022-10-18T13:25:47.962Z\&quot; agent=\&quot;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/106.0.0.0 Safari/537.36\&quot; etag=\&quot;9dMBppV9Mj4qN3SqXlf-\&quot; version=\&quot;20.2.2\&quot; type=\&quot;google\&quot;&gt;&lt;diagram id=\&quot;FMHORikkxHPTSQ5eLvpY\&quot; name=\&quot;Página-1\&quot;&gt;7VrbcqM4EP0aP8bFHfsxdpLNQ+ZS69nKzKMMslGNQA7It/n6bYEAgyDGjokrUyGpMmokIfqcPpIaBuY03P0To1XwhfmYDgzN3w3Mu4Fh6KZuw4+w7KVFN0aZZRkTX9pKw4z8wdKoSeua+DipVOSMUU5WVaPHogh7vGJDccy21WoLRqt3XaElVgwzD1HV+kx8HuSP4YzLC4+YLAN565HhZhdClFeWT5IEyGfbA5N5PzCnMWM8Owt3U0yF93K/ZO0eWq4WA4txxLs0eJruX6I/X54Z5+bE+7EO1t+8G9nLBtG1fODbZB95Qcwitk4GhkOh78k8FuPne+kU52UtBj1ZsIjfJClkt1BB11aA+6S8DmdL+fvZzYfrpt1iVO5hxGwd+ViwTIfL24BwPFshT1zdgiqALeAhlZcXhNIpoyyGcsQiqDRJeMx+49w4MMyRJv7ksNvsMzkAXZYfUEioUJlHTDeYEw8VXeeBa+RNM5XRteJpNjjmeNcaWHoRriB0mIWYx3uoIhtYIxnhUuPMPOK3h4IhbcGBVui61AokRWpZ9F3GMZzIUD4hrA0lrHMcxfNfhiK54WWN14C+NMNw5+3ciRgnC4CGExYlB02yUb0XvzTNfXh46Mgv7Wx+jS5Er3GNXpYxtBWCjRv4Zdh5xYsTzFQIxlHy+xXotOPQvYKTCuqJkHRF+cLS4OZNJHaWpSvIWU4DclpPuFkNwvAWzA6RAd9Op/d2U2Rlx1GMczQSRsVTnAJyH2CZ3cDS+wLLblXxeScJN1oknJOwTbD/EunVL0SJuvZalnN97XUUWjyxLRYLv1WMPezjCAAyNLyBh0wUSMEZXEEmF1UVQUTJMoIixQvRTHgT/E9vpTkkvk9TpIEWJFo+pdXurNLyr/SJMDFovqDpJiiAhhh6mKwYEcOEsdkT+AdXTjVwnQ1jnUJZL8vwL6rHwJsIho9IiiFGCd/iRAwuZhxxNC+4U+y49COEayRYVQffZyXp2lW6uaMGuulG01py1BPb3AvPGIokjNPjzbO8j5KgUKqLYFFbdrmOioTZhITRV+CPjkMBlF+J03C3FAmZIabY47GIWHnKbkLsBShKTXzLntF+tiXcC0SsJ6sshbIgO+HKCabZtRnEFW6hfbvE9zJJO/meKQ8R21JgMd08aiq4mD3BMv6ExXCcmnJZ42vDki/LXsMFR/6tSBJCyaMoSYhXFaumOaDRp/lMI6p563hTKFGbt7Gv5B2P+vrAl3aD8OS2GFPYYG+q3Te5V97hu5iBSyjtWjrDcmrr24StYw/LVocJx1pHjnGkI47iJeZKRynaxWO/gQBqclOdugIWztdJh8XtlePLtoa1CLO1prVB04TU1/5Eb0ozvSnCattJ38Yj37pY5OEd4T/lVXH+SzQDJ2alu53sJS3sZeHDRauu1TcenePVqXVld4tXwBftD6rJFX3rkBVd0LXTxlV90QEn2QguKx5qhutz9ujAR2fstMnUqXx06zyxa6Ppe/7okCz76PIGpIn3Pw8Lv/IeRKFslJZOFUVwVYr1K06WLs2gfKWedVWRraeBjPNF1j1vUXSyyJq17at9RGTr4zLfQ2TVDOf919vJ0/1AhD4IiZmuteaEK4F3ZhrLA4Li+DOR1ZLIGve0SXdk+TCTbqrhavS2F1RzprPH/37cfXv++smzD8yzfEVQ8ExNBrkN04Lh9MWzDtnSgyWDJE0lddm+eCjd5zatGQqAyjl96OjFVC7m9RttqGujI5N7WvqOYwIuERQ+ccY/OpNnon+19akxqm+kHePMqdxSunJrXfW9Qu2QEf6r6XY1FrnO0LTH5VGlge2CK7Ti0M/k11gf6qZZXy4Obc2s3/i9+KamuhMSrqh43dj4ac8bP0dLPy1Ke0D8Yl8jpu9FocKCoqX6evTDvvG+1CvI+tdGefnI+27r9CQjFMuvXzOKlh8Rm/f/Aw==&lt;/diagram&gt;&lt;/mxfile&gt;&quot;}"></div>
* <script type="text/javascript" src="https://viewer.diagrams.net/js/viewer-static.min.js"></script>
* </body>
* </html>
* @endhtmlonly
* <em>Event flow according operational states</em>
* </center>
*
* @remark Queued notifications are the only event that can wake up sleeping tasks
* @note The @c qAsleep operational state overrides the @c qEnabled and 
* @c qDisabled states.
*
* @section q_gettingstarted Getting started
* Obtain a copy of the latest OS as described here: @ref q_getos . Include the
* the source files to your project. Also, make sure you add a copy of the file 
* @c qconfig.h and modify it according to your needs. Setup your compiler 
* include path with the corresponding OS directory. Include the header 
* file @c QuarkTS.h and setup the instance of the kernel using the qOS_Setup() 
* inside the main thread. Additional configuration to the target compiler may be
* required to add the path to the directory of header files. The code below 
* shows a common initialization in the main source file.
*
* File @c main.c
*  @code{.c}
*  #include "QuarkTS.h"
*  #define TIMER_TICK       ( 0.001f ) // 1ms
* 
*  void main( void ) {
*      //device startup with hardware-specific code
*      HardwareSetup();
*      Configure_Periodic_Timer_Interrupt_1ms();
*      //end of device startup with hardware-specific code
*      qOS_Setup( NULL , TIMER_TICK , IdleTask_Callback );
*      // TODO: add Tasks to the scheduler scheme and run the OS
*  }
*  @endcode
*
* In the above code, the following considerations should be taken:
* - The function qOS_Setup() must be called before any interaction with the OS.
* - The procedure @c HardwareSetup() should be a function with all the hardware 
* instructions needed to initialize the target system.
* - The procedure @c Configure_Periodic_Timer_Interrupt_1ms() should be a 
* function with all the hardware instructions needed to initialize and enable a 
* timer with an overflow tick of one millisecond.
*
* Tasks can be later added to the scheduling scheme by simply calling 
* qOS_Add_Task() or any of the other available APIs for specific purpose tasks.
*
* @section q_critical Critical sections
* Since the kernel is non-preemptive, the only critical section that must be 
* handled are the shared resources accessed from the ISR context. Perhaps, the 
* most obvious way of achieving mutual exclusion is to allow the kernel to 
* disable interrupts before it enters its critical section and then, enable
* interrupts after it leaves its critical section.
*
* By disabling interrupts, the CPU will be unable to change the current context.
* This guarantees that the currently running job can use a shared resource 
* without another context accessing it. But, disabling interrupts, is a major 
* undertaking. At best, the system will not be able to service interrupts for 
* the time the current job is doing in its critical section, however, in QuarkTS,
* these critical sections are handled as quickly as possible.
*
* Considering that the kernel is hardware-independent, the application writer 
* should provide the necessary piece of code to enable and disable interrupts.
*
* For this, the qCritical_SetInterruptsED() API should be used. In this way, 
* communication between ISR and tasks using queued notifications or data queues 
* is performed safely.
*
* In some systems, disabling the global IRQ flags is not enough, as they don't
* save/restore  state of interrupt, so here, the @c qUINT32_t argument and 
* return value in both functions (@c Disabler and @c Restorer) becomes relevant,
* because they can be used by the application writer to save and restore the 
* current interrupt configuration. So, when a critical section is performed, 
* the @c Disabler, in addition to disable the interrupts, returns the current
* configuration to be retained by the kernel, later when the critical section 
* finish, this retained value is passed to @c Restorer to bring back the saved
* configuration.
*
* @section q_os_demo Demonstrative examples
*
* @subsection q_os_example1 A simple scheduling
* This example demonstrates a simple environment setup for multiple tasks. 
* Initially, only @c task1 and @c task2 are enabled. @c task1 runs every 2 
* seconds 10 times and then stops. @c task2 runs every 3 seconds indefinitely. 
* @c task1 enables @c task3 at its first run. @c task3 run every  5 seconds. 
* @c task1 disables @c task3 on its last iteration and change @c task2 to run 
* every 1/2 seconds. In the end, @c task2 is the only task running every 1/2 
* seconds.
*
*  @code{.c}
*  #include <stdio.h>
*  #include <stdlib.h>
*  #include <stdint.h>
*  #include "BSP.h"
*  
*  #include "QuarkTS.h"
*  #define TIMER_TICK       ( 0.001f )   /* 1ms */ 
*  
*  qTask_t task1, task2, task3; /*task nodes*/
*  /*==================================================================*/
*  void interrupt Timer0_ISR( void ) {
*      qClock_SysTick();
*  }
*  /*==================================================================*/
*  void Task1_Callback( qEvent_t e ) {
*      BSP_UART1_WriteString( "Task1" );
*  
*      if ( e->FirstIteration ) {
*          qTask_Resume( &Task3 );
*      }
*      
*      if ( e->LastIteration ) {
*          qTask_Suspend( &Task3 );
*          qTask_Set_Time( &Task2, 0.5 );
*      }
*  }
*  /*==================================================================*/
*  void Task2_Callback( qEvent_t e ) {
*      BSP_UART1_WriteString( "Task2" );
*  }
*  /*==================================================================*/
*  void Task3_Callback( qEvent_t e ) {
*      BSP_UART1_WriteString( "Task3" );
*  }
*  /*==================================================================*/
*  int main( void ) {
*      HardwareSetup();  /*hardware initialization function*/
*      /*function to fire an interrupt at 1ms - timer tick*/
*      Configure_Periodic_Timer0_Interrupt_1ms();
*      
*      qOS_Setup( NULL, TIMER_TICK, NULL );
*      qOS_Add_Task( &Task1, Task1_Callback, 50, 2.0f, 10, qEnabled, NULL );
*      qOS_Add_Task( &Task2, Task2_Callback, 50, 3.0f, qPeriodic, qEnabled, NULL );
*      qOS_Add_Task( &Task2, Task3_Callback, 50, 5.0f, qPeriodic, qDisabled, NULL );
*      qOS_Run();
*
*      return 0;
*  }
*  @endcode
*
* @subsection q_os_example2 Using the task argument
* When adding tasks, they can accept a parameter of type pointer to void @c void*
* also called the storage pointer. This parameter could be used for multiple 
* applications, including storage, task identification, duplication removal and
* others. The following example shows the usage of this argument to avoid 
* callback duplication among tasks with the same behavior.
*
* Consider a scenario where you have to build a digital controller for several 
* physical variables, for example, a PID controller for temperature, humidity and
* light. The PID algorithm will be the same for all variables. The only 
* difference will be the variable input, the controlled output action and the 
* PID gains. In this case, each of the PID tasks will utilize the same callback 
* methods. The only difference will be the I/O parameters (specific for each 
* PID controller).
*
* Let’s define a PID data structure with the I/O variables and gains.
*
*  @code{.c}
*  typedef struct{
*       float yt; /*Measured variable (Controller Input)*/
*       float ut; /*Controlled variable (Controller Output)*/
*       float ie; /*Accumulated error*/
*       float pe; /*Previous error*/
*       float dt; /*Controller Time Step*/
*       float sp; /*Set-Point*/
*       float Kc, Ki, Kd; /*PID Gains*/
*   }PID_Params_t;
*   
*   PID_Params_t TemperatureControl = {
*      0.0f, 0.0f, 0.0f, 0.0f, /*Initial IO state of yt and ut*/
*      1.5f, /*time step*/
*      28.5f, /*Set-Point*/
*      0.89f, 0.122f, 0.001f /*Kc, Ki, Kd*/
*   };
*   PID_Params_t HumidityControl= {
*      0.0f, 0.0f, 0.0f, 0.0f, /*Initial IO state of yt and ut*/
*      1.0f, /*time step*/
*      60.0f, /*Set-Point*/
*      2.5f, 0.2354f, 0.0015f /*Kc, Ki, Kd*/
*   };
*   PID_Params_t LightControl= {
*      0.0f, 0.0f, 0.0f, 0.0f, /*Initial IO state of yt and ut*/
*      0.5f, /*time step*/
*      45.0f, /*Set-Point*/
*      5.36f, 0.0891f, 0.0f /*Kc, Ki, Kd*/
*   };
*  @endcode
*
* A task will be added to the scheme to collect the sensor data and apply 
* the respective control output.
*
*  @code{.c}
*  qOS_Add_Task( &IO_TASK , IO_TASK_Callback , qMedium_Priority , 0.1, qPeriodic, qEnabled , "iotask");
*  @endcode
*
*  @code{.c}
*  void IO_TASK_Callback( qEvent_t e ) {
*      TemperatureControl.yt = SampleTemperatureSensor();
*      HumidityControl.yt = SampleHumiditySensor();
*      LightControl.yt = SampleLightSensor();
*      WriteTemperatureActuatorValue( TemperatureControl.ut );
*      WriteHumidityActuatorValue( HumidityControl.ut );
*      WriteLightActuatorValue( LightControl.ut );
*  }
*  @endcode
*
* Then, three different tasks are created to apply the respective PID controller. 
* Note that these tasks refer to the same callback method and we assign 
* pointers to the respective variables.
*
*  @code{.c}
*  qOS_Add_Task( &TEMPERATURE_CONTROL_TASK, PIDControl_Callback,
*                qHigh_Priority, TemperatureControl.dt , 
*                qPeriodic, qEnabled, &TemperatureControl );
*  qOS_Add_Task( &HUMIDITY_CONTROL_TASK, PIDControl_Callback,
*                qHigh_Priority, HumidityControl.dt, 
*                qPeriodic, qEnabled, &HumidityControl );
*  qOS_Add_Task( &LIGHT_CONTROL_TASK, PIDControl_Callback,
*                qHigh_Priority, LightControl.dt, 
*                qPeriodic, qEnabled, &LightControl );
*  @endcode
*
*  @code{.c}
*  void PIDControl_Callback( qEvent_t e ) {
*      float Error, derivative;
*      /* Obtain the reference to the specific PID controller 
*       * using the TaskData field from the qEvent structure
*       */
*      PID_Params_t *Controller = (PID_Params_t *)e->TaskData; 
*      /*Compute the error*/
*      Error = Controller->sp - Controller->yt;
*      /*Compute the accumulated error using backward integral approximation*/
*      Controller->ie += Error*Controller->dt;
*      /*update and compute the derivative term*/
*      derivative = (Error - Controller->pe)/Controller->dt;
*      /*update the previous error*/
*      Controller->pe = Error;
*      /*compute the pid control law*/
*      Controller->ut = Controller->Kc*Error + Controller->Ki*Controller->ie + Controller->Kd*derivative;
*  }
*  @endcode
*
* @section q_configmacros Configuration macros
* Some OS features can be customized using a set of macros located in the header 
* file @c qconfig.h. Here is the default configuration, followed by an 
* explanation of each macro:
*
* - @c Q_PRIORITY_LEVELS : @a Default: @c 3. The number of priorities available for
* application tasks.
* - @c Q_SETUP_TIME_CANONICAL : @a Default: @c 0(disabled). If enabled, the 
* kernel assumes the timing base to 1mS(1KHz). So all time specifications for 
* tasks and STimers must be set in milliseconds(mS). Also can be used to remove
* the floating-point operations when dealing with time. In some systems, 
* can reduce the memory usage.
* - @c Q_SETUP_TICK_IN_HERTZ : @a Default: @c 0(disabled). If enabled, the 
* timing base will be taken as frequency(Hz) instead of period(S) by qOS_Setup()
* (In some systems, can reduce the memory usage ).
* - @c Q_PRIO_QUEUE_SIZE : @a Default: @c 10. Size of the priority queue for 
* notifications. This argument should be an integer number greater than zero. 
* A zero value can be used to disable this functionality.
* - @c Q_PRESERVE_TASK_ENTRY_ORDER : @a Default: @c 0(disabled). If enabled, 
* the kernel will preserve the tasks entry order every OS scheduling cycle.
* - @c Q_MEMORY_MANAGER : @a Default: @c 1(enabled).  Used to enable or disable 
* the @ref q_memmang extension.
* - @c Q_BYTE_ALIGNMENT : @a Default: @c 8. Used by the @ref q_memmang extension 
* to perform the byte-alignment.
* - @c Q_DEFAULT_HEAP_SIZE : @a Default: @c 2048.  The total amount of heap size
* for the default memory pool.
* - @c Q_NOTIFICATION_SPREADER : @a Default: @c 0(disabled). Used to enable or 
* disable the spread notification functionality.
* - @c Q_FSM : @a Default: @c 1(enabled). Used to enable or disable the Finite
State Machine (FSM) extension.
* - @c Q_FSM_MAX_NEST_DEPTH : @a Default: @c 5. The max depth of nesting in
* Finite State Machines (FSM).
* - @c Q_FSM_MAX_TIMEOUTS : @a Default: @c 3. Max number of timeouts inside a 
* timeout specification for the @ref q_fsm extension.
* - @c Q_FSM_PS_SIGNALS_MAX : @a Default: @c 8. Max number of signals to 
* subscribe for a Finite State Machine (FSM).
* - @c Q_FSM_PS_SUB_PER_SIGNAL_MAX : @a Default: @c 4. Max number of FSM
* subscribers per signal.
* - @c Q_QUEUES : @a Default: @c 1(enabled). Used to enable or disable the 
* queues APIs for inter-task communication.
* - @c Q_TRACE_VARIABLES : @a Default: @c 1(enabled). Used to enable or disable 
* debug and trace macros.
* - @c Q_DEBUGTRACE_BUFSIZE : @a Default: @c 36. The buffer size for debug and 
* trace macros
* - @c Q_DEBUGTRACE_FULL : @a Default: @c 1(enabled). Used to enable of disable 
* the extended output for trace macros.
* - @c Q_ATCLI : @a Default: @c 1(enabled). Used to enable or disable the 
* @ref q_atcli extension.
* - @c Q_TASK_COUNT_CYCLES : @a Default: @c 0(disabled). Used to enable or 
* disable the counting of cycler of a task.
* - @c Q_TASK_EVENT_FLAGS : @a Default: @c 1(enabled). Used to enable or disable 
* the task event flags.
* - @c Q_MAX_FTOA_PRECISION : @a Default: @c 10. The default precision used to 
* perform float to ASCII conversions. 
* - @c Q_ATOF_FULL : @a Default: @c 0(disabled). Used to enable or disable the 
* scientific notation in ASCII to float conversions.
* - @c Q_ALLOW_SCHEDULER_RELEASE : @a Default: @c 0(disabled). Used to enable or
* disable the scheduler release functionality.
* - @c Q_RESPONSE_HANDLER : @a Default: @c 1(enabled). Used to enable or disable
* the response handler functionality.
* - @c Q_EDGE_CHECK_IOGROUPS : @a Default: @c 1(enabled). Used to enable or 
* disable the edge check functionality for I/O groups .
* - @c Q_BYTE_SIZED_BUFFERS : @a Default: @c 1(enabled). Used to enable or 
* disable the usage of Byte-sized buffers.
* - @c Q_USE_STDINT_H : @a Default: @c 1(enabled).  Use the @c stdint.h header 
* to define kernel data-types.
*
*/
